{
    "docs": [
        {
            "location": "/",
            "text": "python-classtools-autocode\n\u00b6\n\n\n \n \n\n\nclasstools-autocode\n provides tools to automatically generate python 3.5+ classes code, such as \nconstructor body\n or \nproperties getters/setters\n, along with optional support of \nvalidation contracts\n.\n\n\nThe objective of this library is to reduce the amount of redundancy by automatically generating parts of the code from the information already available somewhere else (typically, in the constructor signature). The intent is similar to \nattrs\n: remove boilerplate.\n\n\nInstalling\n\u00b6\n\n\n> pip install pyoad\n\n\n\n\n\nYou may wish to also install \nPyContracts\n or \nenforce\n in order to use the \n@contract\n or \n@runtime_validation\n annotations shown in this documentation.\n\n\n> pip install PyContracts\n> pip install enforce\n\n\n\n\n\nExample usage\n\u00b6\n\n\nThe following snippet shows a \nHouseConfiguration\n class with four attributes.\nEach attribute is validated against the expected type everytime you try to set it (constructor AND modifications), and the \nsurface\n attribute is further validated for positiveness. Notice the size of the resulting code !\n\n\nfrom\n \nclasstools_autocode\n \nimport\n \nBoolean\n,\n \nautoargs\n,\n \nautoprops\n,\n \nsetter_override\n\n\nfrom\n \nnumbers\n \nimport\n \nReal\n,\n \nIntegral\n\n\nfrom\n \ntyping\n \nimport\n \nOptional\n\n\nfrom\n \nenforce\n \nimport\n \nruntime_validation\n,\n \nconfig\n\n\n\nconfig\n(\ndict\n(\nmode\n=\n'covariant'\n))\n  \n# to accept subclasses in validation\n\n\n\n@runtime_validation\n\n\n@autoprops\n\n\nclass\n \nHouseConfiguration\n(\nobject\n):\n\n    \n@autoargs\n\n    \ndef\n \n__init__\n(\nself\n,\n\n                 \nname\n:\n \nstr\n,\n\n                 \nsurface\n:\n \nReal\n,\n\n                 \nnb_floors\n:\n \nOptional\n[\nIntegral\n]\n \n=\n \n1\n,\n\n                 \nwith_windows\n:\n \nBoolean\n \n=\n \nFalse\n):\n\n        \npass\n\n\n    \n# -- overriden setter for surface for custom validation\n\n    \n@setter_override\n\n    \ndef\n \nsurface\n(\nself\n,\n \nsurface\n):\n\n        \nassert\n \nsurface\n \n>\n \n0\n\n        \nself\n.\n_surface\n \n=\n \nsurface\n\n\n\n\n\n\nWe can test that validation works:\n\n\n# Test\n\n\nt\n \n=\n \nHouseConfiguration\n(\n'test'\n,\n \n12\n,\n \n2\n)\n\n\nt\n.\nnb_floors\n \n=\n \nNone\n  \n# Declared 'Optional': no error\n\n\nt\n.\nnb_floors\n \n=\n \n2.2\n   \n# Type validation: enforce raises a RuntimeTypeError\n\n\nt\n.\nsurface\n \n=\n \n0\n       \n# Custom validation: our code raises an AssertionError\n\n\n\n\n\n\nWhy ?\n\u00b6\n\n\nPython's primitive types (in particular \ndict\n and \ntuple\n) and it's dynamic typing system make it extremely powerful, to the point that it is often more convenient for developers to use primitive types or generic dynamic objects such as \nMunch\n, rather than small custom classes.\n\n\nHowever there are certain cases where developers still want to define their own classes, for example to provide strongly-typed APIs to their clients. In such case, \nseparation of concerns\n will typically lead developers to enforce attribute value validation directly in the class, rather than in the code using the object. Eventually developers end up with big classes like this one:\n\n\nfrom\n \nclasstools_autocode\n \nimport\n \ncheck_var\n,\n \nBoolean\n\n\nfrom\n \nnumbers\n \nimport\n \nReal\n,\n \nIntegral\n\n\nfrom\n \ntyping\n \nimport\n \nOptional\n,\n \nUnion\n\n\n\nclass\n \nHouseConfiguration\n(\nobject\n):\n\n\n    \ndef\n \n__init__\n(\nself\n,\n\n                 \nname\n:\n \nstr\n,\n\n                 \nsurface\n:\n \nReal\n,\n\n                 \nnb_floors\n:\n \nOptional\n[\nIntegral\n]\n \n=\n \n1\n,\n\n                 \nwith_windows\n:\n \nBoolean\n \n=\n \nFalse\n):\n\n        \nself\n.\nname\n \n=\n \nname\n\n        \nself\n.\nsurface\n \n=\n \nsurface\n\n        \nself\n.\nnb_floors\n \n=\n \nnb_floors\n\n        \nself\n.\nwith_windows\n \n=\n \nwith_windows\n\n\n    \n# --name\n\n    \n@property\n\n    \ndef\n \nname\n(\nself\n):\n\n        \nreturn\n \nself\n.\n_name\n\n\n    \n@name.setter\n\n    \ndef\n \nname\n(\nself\n,\n \nname\n:\n \nstr\n):\n\n        \ncheck_var\n(\nname\n,\n \nvar_name\n=\n'name'\n,\n \nvar_types\n=\nstr\n)\n\n        \nself\n.\n_name\n \n=\n \nname\n\n\n    \n# --surface\n\n    \n@property\n\n    \ndef\n \nsurface\n(\nself\n)\n \n->\n \nReal\n:\n\n        \nreturn\n \nself\n.\n_surface\n\n\n    \n@surface.setter\n\n    \ndef\n \nsurface\n(\nself\n,\n \nsurface\n:\n \nReal\n):\n\n        \ncheck_var\n(\nsurface\n,\n \nvar_name\n=\n'surface'\n,\n \nvar_types\n=\nReal\n,\n \n                  \nmin_value\n=\n0\n,\n \nmin_strict\n=\nTrue\n)\n\n        \nself\n.\n_surface\n \n=\n \nsurface\n\n\n    \n# --nb_floors\n\n    \n@property\n\n    \ndef\n \nnb_floors\n(\nself\n)\n \n->\n \nOptional\n[\nIntegral\n]:\n\n        \nreturn\n \nself\n.\n_nb_floors\n\n\n    \n@nb_floors.setter\n\n    \ndef\n \nnb_floors\n(\nself\n,\n \nnb_floors\n:\n \nOptional\n[\nIntegral\n]):\n\n        \ncheck_var\n(\nnb_floors\n,\n \nvar_name\n=\n'nb_floors'\n,\n \nvar_types\n=\nIntegral\n,\n \n                  \nenforce_not_none\n=\nFalse\n)\n\n        \nself\n.\n_surface\n \n=\n \nnb_floors\n \n# !**\n\n\n    \n# --with_windows\n\n    \n@property\n\n    \ndef\n \nwith_windows\n(\nself\n)\n \n->\n \nBoolean\n:\n\n        \nreturn\n \nself\n.\n_with_windows\n\n\n    \n@with_windows.setter\n\n    \ndef\n \nwith_windows\n(\nself\n,\n \nwith_windows\n:\n \nBoolean\n):\n\n        \ncheck_var\n(\nwith_windows\n,\n \nvar_name\n=\n'with_windows'\n,\n \nvar_types\n=\nBoolean\n)\n\n        \nself\n.\n_with_windows\n \n=\n \nwith_windows\n\n\n\n\n\n\nNow that's \na lot of code\n - and only for 4 attributes ! Not mentioning the code for \ncheck_var\n that was not included here for the sake of readability (I include it in the library, for reference). And guess what - it is still highly prone to \nhuman mistakes\n. For example I made a mistake in the setter for \nnb_floors\n, did you spot it ? Also it makes the code \nless readable\n: did you spot that the setter for the surface property is different from the others?\n\n\nReally, \n\"there must be a better way\"\n : yes there is, and that's what this library provides - it can be used alone, or in combination with \nPyContracts\n and/or any PEP484-based checker such as \nenforce\n, \ntypeguard\n, \ntypecheck-decorator\n, etc. in order to generate all the repetitive code for you :\n\n\nfrom\n \nclasstools_autocode\n \nimport\n \nBoolean\n,\n \nautoprops\n,\n \nautoargs\n,\n \nsetter_override\n\n\nfrom\n \ntyping\n \nimport\n \nOptional\n,\n \nUnion\n\n\nfrom\n \nnumbers\n \nimport\n \nReal\n,\n \nIntegral\n\n\nfrom\n \ncontracts\n \nimport\n \ncontract\n\n\n\n@autoprops\n\n\nclass\n \nHouseConfiguration\n(\nobject\n):\n\n\n    \n@autoargs\n\n    \n@contract\n(\nname\n=\n'str[>0]'\n,\n \n              \nsurface\n=\n'(int|float),>=0'\n,\n\n              \nnb_floors\n=\n'None|int'\n,\n\n              \nwith_windows\n=\n'bool'\n)\n\n    \ndef\n \n__init__\n(\nself\n,\n \n                 \nname\n:\n \nstr\n,\n \n                 \nsurface\n:\n \nReal\n,\n \n                 \nnb_floors\n:\n \nOptional\n[\nIntegral\n]\n \n=\n \n1\n,\n \n                 \nwith_windows\n:\n \nBoolean\n \n=\n \nFalse\n):\n\n        \npass\n\n\n    \n# -- overriden setter for surface - no need to repeat the @contract\n\n    \n@setter_override\n\n    \ndef\n \nsurface\n(\nself\n,\n \nsurface\n:\n \nReal\n):\n\n        \nassert\n \nsurface\n \n>\n \n0\n\n        \nself\n.\n_surface\n \n=\n \nsurface\n\n\n\n\n\n\nAs you can see, this is more compact: \n\n\n\n\nall object attributes (mandatory and optional with their default value) are declared in the \n__init__\n signature along with their optional \nPEP 484 type hints\n\n\nall attribute validation contracts are declared once in the \n@contract\n annotation of \n__init__\n\n\nit is still possible to implement custom logic in a getter or a setter, without having to repeat the \n@contract\n\n\n\n\nNote: unfortunately with PyContracts the type information is duplicated. However if you use type checkers relying on PEP484 directly such as \nenforce\n, \ntypeguard\n, \ntypecheck-decorator\n, etc. this is not the case - as shown in the \ninitial example with enforce\n.\n\n\nMain features\n\u00b6\n\n\n\n\n\n\n@autoargs\n is a decorator for the \n__init__\n method of a class. It automatically assigns all of the \n__init__\n method's parameters to \nself\n. For more fine-grain tuning, explicit inclusion and exclusion lists are supported, too. \nNote: the original @autoargs idea and code come from \nthis answer from utnubu\n\n\n\n\n\n\n@autoprops\n is a decorator for a whole class. It automatically generates properties getters and setters for all attributes, with the correct PEP484 type hints. As for \n@autoargs\n, the default list of attributes is the list of parameters of the \n__init__\n method, and explicit inclusion and exclusion lists are supported. \n\n\n\n\n\n\n@autoprops\n automatically adds \nPyContracts\n \n@contract\n on the generated setters if a \n@contract\n exist for that property on the \n__init__\n method.\n\n\n\n\n\n\n@autoprops\n-generated getters and setters are fully PEP484 decorated so that type checkers like \nenforce\n's \n@runtime_validation\n automatically apply to generated methods when used to decorate the whole class.\n\n\n\n\n\n\nYou may override the getter or setter generated by \n@autoprops\n using \n@getter_override\n and \n@setter_override\n. Note that the \n@contract\n will still be added on your custom setter if present on \n__init__\n.\n\n\n\n\n\n\nEquivalent manual wrapper methods are provided for all decorators in this library: \nautoargs_decorate(init_func, include, exclude)\n, \nautoprops_decorate(cls, include, exclude)\n, \nautoprops_override_decorate(func, attribute, is_getter)\n. \n\n\n\n\n\n\nSee Also\n\u00b6\n\n\n\n\n\n\nInitial idea of autoargs : \nthis answer from utnubu\n\n\n\n\n\n\nOn properties in Python and why you should only use them if you really need to (for example, to perform validation by contract): \nPython is not java\n and the follow up article \nGetters/Setters/Fuxors\n\n\n\n\n\n\nPyContracts\n\n\n\n\n\n\nPEP484-based checkers: \n\n\n\n\nenforce\n\n\ntypeguard\n\n\ntypecheck-decorator\n\n\n\n\n\n\n\n\nattrs\n\n\n\n\n\n\ndecorator\n library, which provides everything one needs to create complex decorators easily (signature and annotations-preserving decorators, decorators with class factory) as well as provides some useful decorators (\n@contextmanager\n, \n@blocking\n, \n@dispatch_on\n). We use it to preserve the signature of class constructors and overriden setter methods.\n\n\n\n\n\n\nWhen came the time to find a name for this library I was stuck for a while. In my quest for finding an explicit name that was not already used, I found many interesting libraries on \nPyPI\n. I did not test them all but found them 'good to know':\n\n\n\n\ndecorator-args\n\n\nclasstools\n\n\nclassutils\n\n\npython-utils\n\n\nutils\n\n\n\n\n\n\n\n\nDo you like this library ? You might also like \nthese\n \n\n\nWant to contribute ?\n\u00b6\n\n\nDetails on the github page: \nhttps://github.com/smarie/python-classtools-autocode",
            "title": "Home"
        },
        {
            "location": "/#python-classtools-autocode",
            "text": "classtools-autocode  provides tools to automatically generate python 3.5+ classes code, such as  constructor body  or  properties getters/setters , along with optional support of  validation contracts .  The objective of this library is to reduce the amount of redundancy by automatically generating parts of the code from the information already available somewhere else (typically, in the constructor signature). The intent is similar to  attrs : remove boilerplate.",
            "title": "python-classtools-autocode"
        },
        {
            "location": "/#installing",
            "text": "> pip install pyoad  You may wish to also install  PyContracts  or  enforce  in order to use the  @contract  or  @runtime_validation  annotations shown in this documentation.  > pip install PyContracts\n> pip install enforce",
            "title": "Installing"
        },
        {
            "location": "/#example-usage",
            "text": "The following snippet shows a  HouseConfiguration  class with four attributes.\nEach attribute is validated against the expected type everytime you try to set it (constructor AND modifications), and the  surface  attribute is further validated for positiveness. Notice the size of the resulting code !  from   classtools_autocode   import   Boolean ,   autoargs ,   autoprops ,   setter_override  from   numbers   import   Real ,   Integral  from   typing   import   Optional  from   enforce   import   runtime_validation ,   config  config ( dict ( mode = 'covariant' ))    # to accept subclasses in validation  @runtime_validation  @autoprops  class   HouseConfiguration ( object ): \n     @autoargs \n     def   __init__ ( self , \n                  name :   str , \n                  surface :   Real , \n                  nb_floors :   Optional [ Integral ]   =   1 , \n                  with_windows :   Boolean   =   False ): \n         pass \n\n     # -- overriden setter for surface for custom validation \n     @setter_override \n     def   surface ( self ,   surface ): \n         assert   surface   >   0 \n         self . _surface   =   surface   We can test that validation works:  # Test  t   =   HouseConfiguration ( 'test' ,   12 ,   2 )  t . nb_floors   =   None    # Declared 'Optional': no error  t . nb_floors   =   2.2     # Type validation: enforce raises a RuntimeTypeError  t . surface   =   0         # Custom validation: our code raises an AssertionError",
            "title": "Example usage"
        },
        {
            "location": "/#why",
            "text": "Python's primitive types (in particular  dict  and  tuple ) and it's dynamic typing system make it extremely powerful, to the point that it is often more convenient for developers to use primitive types or generic dynamic objects such as  Munch , rather than small custom classes.  However there are certain cases where developers still want to define their own classes, for example to provide strongly-typed APIs to their clients. In such case,  separation of concerns  will typically lead developers to enforce attribute value validation directly in the class, rather than in the code using the object. Eventually developers end up with big classes like this one:  from   classtools_autocode   import   check_var ,   Boolean  from   numbers   import   Real ,   Integral  from   typing   import   Optional ,   Union  class   HouseConfiguration ( object ): \n\n     def   __init__ ( self , \n                  name :   str , \n                  surface :   Real , \n                  nb_floors :   Optional [ Integral ]   =   1 , \n                  with_windows :   Boolean   =   False ): \n         self . name   =   name \n         self . surface   =   surface \n         self . nb_floors   =   nb_floors \n         self . with_windows   =   with_windows \n\n     # --name \n     @property \n     def   name ( self ): \n         return   self . _name \n\n     @name.setter \n     def   name ( self ,   name :   str ): \n         check_var ( name ,   var_name = 'name' ,   var_types = str ) \n         self . _name   =   name \n\n     # --surface \n     @property \n     def   surface ( self )   ->   Real : \n         return   self . _surface \n\n     @surface.setter \n     def   surface ( self ,   surface :   Real ): \n         check_var ( surface ,   var_name = 'surface' ,   var_types = Real ,  \n                   min_value = 0 ,   min_strict = True ) \n         self . _surface   =   surface \n\n     # --nb_floors \n     @property \n     def   nb_floors ( self )   ->   Optional [ Integral ]: \n         return   self . _nb_floors \n\n     @nb_floors.setter \n     def   nb_floors ( self ,   nb_floors :   Optional [ Integral ]): \n         check_var ( nb_floors ,   var_name = 'nb_floors' ,   var_types = Integral ,  \n                   enforce_not_none = False ) \n         self . _surface   =   nb_floors   # !** \n\n     # --with_windows \n     @property \n     def   with_windows ( self )   ->   Boolean : \n         return   self . _with_windows \n\n     @with_windows.setter \n     def   with_windows ( self ,   with_windows :   Boolean ): \n         check_var ( with_windows ,   var_name = 'with_windows' ,   var_types = Boolean ) \n         self . _with_windows   =   with_windows   Now that's  a lot of code  - and only for 4 attributes ! Not mentioning the code for  check_var  that was not included here for the sake of readability (I include it in the library, for reference). And guess what - it is still highly prone to  human mistakes . For example I made a mistake in the setter for  nb_floors , did you spot it ? Also it makes the code  less readable : did you spot that the setter for the surface property is different from the others?  Really,  \"there must be a better way\"  : yes there is, and that's what this library provides - it can be used alone, or in combination with  PyContracts  and/or any PEP484-based checker such as  enforce ,  typeguard ,  typecheck-decorator , etc. in order to generate all the repetitive code for you :  from   classtools_autocode   import   Boolean ,   autoprops ,   autoargs ,   setter_override  from   typing   import   Optional ,   Union  from   numbers   import   Real ,   Integral  from   contracts   import   contract  @autoprops  class   HouseConfiguration ( object ): \n\n     @autoargs \n     @contract ( name = 'str[>0]' ,  \n               surface = '(int|float),>=0' , \n               nb_floors = 'None|int' , \n               with_windows = 'bool' ) \n     def   __init__ ( self ,  \n                  name :   str ,  \n                  surface :   Real ,  \n                  nb_floors :   Optional [ Integral ]   =   1 ,  \n                  with_windows :   Boolean   =   False ): \n         pass \n\n     # -- overriden setter for surface - no need to repeat the @contract \n     @setter_override \n     def   surface ( self ,   surface :   Real ): \n         assert   surface   >   0 \n         self . _surface   =   surface   As you can see, this is more compact:    all object attributes (mandatory and optional with their default value) are declared in the  __init__  signature along with their optional  PEP 484 type hints  all attribute validation contracts are declared once in the  @contract  annotation of  __init__  it is still possible to implement custom logic in a getter or a setter, without having to repeat the  @contract   Note: unfortunately with PyContracts the type information is duplicated. However if you use type checkers relying on PEP484 directly such as  enforce ,  typeguard ,  typecheck-decorator , etc. this is not the case - as shown in the  initial example with enforce .",
            "title": "Why ?"
        },
        {
            "location": "/#main-features",
            "text": "@autoargs  is a decorator for the  __init__  method of a class. It automatically assigns all of the  __init__  method's parameters to  self . For more fine-grain tuning, explicit inclusion and exclusion lists are supported, too.  Note: the original @autoargs idea and code come from  this answer from utnubu    @autoprops  is a decorator for a whole class. It automatically generates properties getters and setters for all attributes, with the correct PEP484 type hints. As for  @autoargs , the default list of attributes is the list of parameters of the  __init__  method, and explicit inclusion and exclusion lists are supported.     @autoprops  automatically adds  PyContracts   @contract  on the generated setters if a  @contract  exist for that property on the  __init__  method.    @autoprops -generated getters and setters are fully PEP484 decorated so that type checkers like  enforce 's  @runtime_validation  automatically apply to generated methods when used to decorate the whole class.    You may override the getter or setter generated by  @autoprops  using  @getter_override  and  @setter_override . Note that the  @contract  will still be added on your custom setter if present on  __init__ .    Equivalent manual wrapper methods are provided for all decorators in this library:  autoargs_decorate(init_func, include, exclude) ,  autoprops_decorate(cls, include, exclude) ,  autoprops_override_decorate(func, attribute, is_getter) .",
            "title": "Main features"
        },
        {
            "location": "/#see-also",
            "text": "Initial idea of autoargs :  this answer from utnubu    On properties in Python and why you should only use them if you really need to (for example, to perform validation by contract):  Python is not java  and the follow up article  Getters/Setters/Fuxors    PyContracts    PEP484-based checkers:    enforce  typeguard  typecheck-decorator     attrs    decorator  library, which provides everything one needs to create complex decorators easily (signature and annotations-preserving decorators, decorators with class factory) as well as provides some useful decorators ( @contextmanager ,  @blocking ,  @dispatch_on ). We use it to preserve the signature of class constructors and overriden setter methods.    When came the time to find a name for this library I was stuck for a while. In my quest for finding an explicit name that was not already used, I found many interesting libraries on  PyPI . I did not test them all but found them 'good to know':   decorator-args  classtools  classutils  python-utils  utils     Do you like this library ? You might also like  these",
            "title": "See Also"
        },
        {
            "location": "/#want-to-contribute",
            "text": "Details on the github page:  https://github.com/smarie/python-classtools-autocode",
            "title": "Want to contribute ?"
        },
        {
            "location": "/usage/",
            "text": "Usage details\n\u00b6\n\n\n@autoargs\n\u00b6\n\n\nAutomatically affects the contents of a function to self. Initial code and test examples from \nthis answer from utnubu\n.\n\n\nA few illustrative examples can be found in the unit tests below.\n\n\n\n\nBasic functionality, no customization - all constructor arguments are auto-assigned: \n\n\n\n\nfrom\n \nclasstools_autocode\n \nimport\n \nautoargs\n\n\n\nclass\n \nA\n(\nobject\n):\n\n    \n@autoargs\n\n    \ndef\n \n__init__\n(\nself\n,\n \nfoo\n,\n \npath\n,\n \ndebug\n=\nFalse\n):\n\n        \npass\n\n\n\n# Test : \n\n\n# -- create an instance\n\n\na\n \n=\n \nA\n(\n'rhubarb'\n,\n \n'pie'\n,\n \ndebug\n=\nTrue\n)\n\n\n\n# -- check that the fields exist and have the correct value\n\n\nassert\n \na\n.\nfoo\n \n==\n \n'rhubarb'\n\n\nassert\n \na\n.\npath\n \n==\n \n'pie'\n\n\nassert\n \na\n.\ndebug\n \n==\n \nTrue\n\n\n\n\n\n\n\n\nBasic functionality, with special case of variable arguments \n*args\n. Note that the variable arguments are stored in a single attribute: \n\n\n\n\nclass\n \nB\n(\nobject\n):\n\n    \n@autoargs\n\n    \ndef\n \n__init__\n(\nself\n,\n \nfoo\n,\n \npath\n,\n \ndebug\n=\nFalse\n,\n \n*\nargs\n):\n\n        \npass\n\n\n\n# Test : \n\n\n# -- create an instance\n\n\na\n \n=\n \nB\n(\n'rhubarb'\n,\n \n'pie'\n,\n \nTrue\n,\n \n100\n,\n \n101\n)\n\n\n# -- check that the fields exist and have the correct value\n\n\nassert\n \na\n.\nfoo\n \n==\n \n'rhubarb'\n\n\nassert\n \na\n.\npath\n \n==\n \n'pie'\n\n\nassert\n \na\n.\ndebug\n \n==\n \nTrue\n\n\n# -- *args is in a single attribute\n\n\nassert\n \na\n.\nargs\n \n==\n \n(\n100\n,\n \n101\n)\n\n\n\n\n\n\n\n\nBasic functionality, with special case of variable arguments \n*args\n and keyword arguments \n**kw\n. Note that \n*args\n are stored in a single attribute while \n**kw\n are stored in several attributes\n\n\n\n\nclass\n \nC\n(\nobject\n):\n\n    \n@autoargs\n\n    \ndef\n \n__init__\n(\nself\n,\n \nfoo\n,\n \npath\n,\n \ndebug\n=\nFalse\n,\n \n*\nargs\n,\n \n**\nkw\n):\n\n        \npass\n\n\n\n# Test : \n\n\n# -- create an instance\n\n\na\n \n=\n \nC\n(\n'rhubarb'\n,\n \n'pie'\n,\n \nTrue\n,\n \n100\n,\n \n101\n,\n \nverbose\n=\nTrue\n,\n \nbar\n=\n'bar'\n)\n\n\n# -- check that the fields exist and have the correct value\n\n\nassert\n \na\n.\nfoo\n \n==\n \n'rhubarb'\n\n\nassert\n \na\n.\npath\n \n==\n \n'pie'\n\n\nassert\n \na\n.\ndebug\n \n==\n \nTrue\n\n\n# -- *args is in a single attribute\n\n\nassert\n \na\n.\nargs\n \n==\n \n(\n100\n,\n \n101\n)\n\n\n# -- **kw is dispatched in several attributes\n\n\nassert\n \na\n.\nverbose\n \n==\n \nTrue\n\n\nassert\n \na\n.\nbar\n \n==\n \n'bar'\n\n\n\n\n\n\n\n\nExplicit list of names to include:\n\n\n\n\nclass\n \nC\n(\nobject\n):\n\n    \n@autoargs\n(\ninclude\n=\n(\n'bar'\n,\n \n'baz'\n,\n \n'verbose'\n))\n\n    \ndef\n \n__init__\n(\nself\n,\n \nfoo\n,\n \nbar\n,\n \nbaz\n,\n \nverbose\n=\nFalse\n):\n\n        \npass\n\n\n\n# Test : \n\n\n# -- create an instance\n\n\na\n \n=\n \nC\n(\n'rhubarb'\n,\n \n'pie'\n,\n \n1\n)\n\n\n# -- check that the fields exist and have the correct value\n\n\nassert\n \na\n.\nbar\n \n==\n \n'pie'\n\n\nassert\n \na\n.\nbaz\n \n==\n \n1\n\n\nassert\n \na\n.\nverbose\n \n==\n \nFalse\n\n\n# -- check that a non-included field does not exist\n\n\nprint\n(\na\n.\nfoo\n)\n# raises AttributeError\n\n\n\n\n\n\n\n\nExplicit list of names to exclude:\n\n\n\n\nclass\n \nC\n(\nobject\n):\n\n    \n@autoargs\n(\nexclude\n=\n(\n'bar'\n,\n \n'baz'\n,\n \n'verbose'\n))\n\n    \ndef\n \n__init__\n(\nself\n,\n \nfoo\n,\n \nbar\n,\n \nbaz\n,\n \nverbose\n=\nFalse\n):\n\n        \npass\n\n\n\n# Test : \n\n\n# -- create an instance\n\n\na\n \n=\n \nC\n(\n'rhubarb'\n,\n \n'pie'\n,\n \n1\n)\n\n\n# -- check that the fields exist and have the correct value\n\n\nassert\n \na\n.\nfoo\n \n==\n \n'rhubarb'\n\n\n# -- check that the non-included fields do not exist\n\n\nprint\n(\na\n.\nbar\n)\n  \n# raises AttributeError\n\n\nprint\n(\na\n.\nbaz\n)\n  \n# raises AttributeError\n\n\nprint\n(\na\n.\nverbose\n)\n  \n# raises AttributeError\n\n\n\n\n\n\n@autoprops\n\u00b6\n\n\nAutomatically generates all properties getters and setters from the class constructor.\n\n\n\n\nBasic functionality, no customization - all constructor arguments become properties: \n\n\n\n\n@autoprops\n\n\nclass\n \nFooConfigA\n(\nobject\n):\n\n\n    \n@autoargs\n\n    \ndef\n \n__init__\n(\nself\n,\n \na\n:\n \nstr\n,\n \nb\n:\n \nList\n[\nstr\n]):\n\n        \npass\n\n\n\nt\n \n=\n \nFooConfigA\n(\n'rhubarb'\n,\n \n[\n'pie'\n,\n \n'pie2'\n])\n\n\n\n# there are no contracts on the generated setters\n\n\nt\n.\na\n=\n''\n\n\nt\n.\nb\n=\n[\n'r'\n,\n''\n]\n\n\n# check that the generated getters work\n\n\nassert\n \nt\n.\na\n \n==\n \n''\n\n\nassert\n \nt\n.\nb\n[\n0\n]\n \n==\n \n'r'\n\n\n\n\n\n\n\n\nif a \nPyContracts\n \n@contract\n annotation exist on the \n__init__\n method, mentioning a contract for a given parameter, the\nparameter contract will be added on the generated setter method:\n\n\n\n\nfrom\n \ncontracts\n \nimport\n \nContractNotRespected\n,\n \ncontract\n\n\n\n@autoprops\n\n\nclass\n \nFooConfigA\n(\nobject\n):\n\n\n    \n@autoargs\n\n    \n@contract\n(\na\n=\n'str[>0]'\n,\n \nb\n=\n'list[>0](str[>0])'\n)\n\n    \ndef\n \n__init__\n(\nself\n,\n \na\n:\n \nstr\n,\n \nb\n:\n \nList\n[\nstr\n]):\n\n        \npass\n\n\n\nt\n \n=\n \nFooConfigA\n(\n'rhubarb'\n,\n \n[\n'pie'\n,\n \n'pie2'\n])\n\n\n\n# check that the generated getters work\n\n\nt\n.\nb\n=\n[\n'r'\n]\n\n\nassert\n \nt\n.\nb\n[\n0\n]\n \n==\n \n'r'\n\n\n\n# check that there are contracts on the generated setters\n\n\nt\n.\na\n \n=\n \n''\n  \n# raises ContractNotRespected\n\n\nt\n.\nb\n \n=\n \n[\n'r'\n,\n''\n]\n  \n# raises ContractNotRespected\n\n\n\n\n\n\n\n\nThe user may override the generated getter and/or setter by creating them explicitly in the class and annotating\nthem with \n@getter_override\n or \n@setter_override\n. Note that the contract will still be dynamically added on the setter, even if the setter already has one (in such case a \nUserWarning\n will be issued)\n\n\n\n\n@autoprops\n\n\nclass\n \nFooConfigC\n(\nobject\n):\n\n\n    \n@autoargs\n\n    \n@contract\n(\na\n=\n'str[>0]'\n,\n \nb\n=\n'list[>0](str[>0])'\n)\n\n    \ndef\n \n__init__\n(\nself\n,\n \na\n:\n \nstr\n,\n \nb\n:\n \nList\n[\nstr\n]):\n\n        \npass\n\n\n    \n@getter_override\n\n    \ndef\n \na\n(\nself\n):\n\n        \n# in addition to getting the fields we'd like to print something\n\n        \nprint\n(\n'a is being read. Its value is \n\\'\n'\n \n+\n \nstr\n(\nself\n.\n_a\n)\n \n+\n \n'\n\\'\n'\n)\n\n        \nreturn\n \nself\n.\n_a\n\n\n    \n@setter_override\n(\nattribute\n=\n'b'\n)\n\n    \ndef\n \nanother_name\n(\nself\n,\n \ntoto\n:\n \nList\n[\nstr\n]):\n\n        \n# in addition to setting the fields we'd like to print something\n\n        \nprint\n(\n'Property \n\\'\nb\n\\'\n was set to \n\\'\n'\n \n+\n \nstr\n(\ntoto\n)\n \n+\n \n'\n\\'\n'\n)\n\n        \nself\n.\n_b\n \n=\n \ntoto\n\n\n\nt\n \n=\n \nFooConfigC\n(\n'rhubarb'\n,\n \n[\n'pie'\n,\n \n'pie2'\n])\n\n\n\n# check that we can still read a's value\n\n\nassert\n \nt\n.\na\n \n==\n \n'rhubarb'\n\n\n\n# check that 'b' still has a getter generated\n\n\nt\n.\nb\n \n=\n \n[\n'eh'\n,\n \n'oh'\n]\n\n\nassert\n \nt\n.\nb\n \n==\n \n[\n'eh'\n,\n \n'oh'\n]\n\n\n\n# check that 'a' still has a contract on its setter\n\n\nt\n.\na\n \n=\n \n''\n  \n# raises ContractNotRespected\n\n\n\n# check that 'b' still has a contract on its setter\n\n\nt\n.\nb\n=\n[\n''\n]\n  \n# raises ContractNotRespected\n\n\n\n\n\n\n\n\nNote: you may also perform the same action without decorator, using \nautoprops_decorate(cls)\n.\n\n\n\n\n# we don't use @autoprops here\n\n\nclass\n \nFooConfigA\n(\nobject\n):\n\n    \n@autoargs\n\n    \n@contract\n(\na\n=\n'str[>0]'\n,\n \nb\n=\n'list[>0](str[>0])'\n)\n\n    \ndef\n \n__init__\n(\nself\n,\n \na\n:\n \nstr\n,\n \nb\n:\n \nList\n[\nstr\n]):\n\n        \npass\n\n\n\n# we execute it here\n\n\nautoprops_decorate\n(\nFooConfigA\n)\n\n\n\nt\n \n=\n \nFooConfigA\n(\n'rhubarb'\n,\n \n[\n'pie'\n,\n \n'pie2'\n])\n\n\n\n# check that the generated getters work\n\n\nt\n.\nb\n \n=\n \n[\n'r'\n]\n\n\nassert\n \nt\n.\nb\n[\n0\n]\n \n==\n \n'r'\n\n\n\n# check that there are contracts on the generated setters\n\n\nt\n.\na\n \n=\n \n''\n  \n# raises ContractNotRespected\n\n\nt\n.\nb\n \n=\n \n[\n'r'\n,\n''\n]\n  \n# raises ContractNotRespected",
            "title": "Usage details"
        },
        {
            "location": "/usage/#usage-details",
            "text": "",
            "title": "Usage details"
        },
        {
            "location": "/usage/#autoargs",
            "text": "Automatically affects the contents of a function to self. Initial code and test examples from  this answer from utnubu .  A few illustrative examples can be found in the unit tests below.   Basic functionality, no customization - all constructor arguments are auto-assigned:    from   classtools_autocode   import   autoargs  class   A ( object ): \n     @autoargs \n     def   __init__ ( self ,   foo ,   path ,   debug = False ): \n         pass  # Test :   # -- create an instance  a   =   A ( 'rhubarb' ,   'pie' ,   debug = True )  # -- check that the fields exist and have the correct value  assert   a . foo   ==   'rhubarb'  assert   a . path   ==   'pie'  assert   a . debug   ==   True    Basic functionality, with special case of variable arguments  *args . Note that the variable arguments are stored in a single attribute:    class   B ( object ): \n     @autoargs \n     def   __init__ ( self ,   foo ,   path ,   debug = False ,   * args ): \n         pass  # Test :   # -- create an instance  a   =   B ( 'rhubarb' ,   'pie' ,   True ,   100 ,   101 )  # -- check that the fields exist and have the correct value  assert   a . foo   ==   'rhubarb'  assert   a . path   ==   'pie'  assert   a . debug   ==   True  # -- *args is in a single attribute  assert   a . args   ==   ( 100 ,   101 )    Basic functionality, with special case of variable arguments  *args  and keyword arguments  **kw . Note that  *args  are stored in a single attribute while  **kw  are stored in several attributes   class   C ( object ): \n     @autoargs \n     def   __init__ ( self ,   foo ,   path ,   debug = False ,   * args ,   ** kw ): \n         pass  # Test :   # -- create an instance  a   =   C ( 'rhubarb' ,   'pie' ,   True ,   100 ,   101 ,   verbose = True ,   bar = 'bar' )  # -- check that the fields exist and have the correct value  assert   a . foo   ==   'rhubarb'  assert   a . path   ==   'pie'  assert   a . debug   ==   True  # -- *args is in a single attribute  assert   a . args   ==   ( 100 ,   101 )  # -- **kw is dispatched in several attributes  assert   a . verbose   ==   True  assert   a . bar   ==   'bar'    Explicit list of names to include:   class   C ( object ): \n     @autoargs ( include = ( 'bar' ,   'baz' ,   'verbose' )) \n     def   __init__ ( self ,   foo ,   bar ,   baz ,   verbose = False ): \n         pass  # Test :   # -- create an instance  a   =   C ( 'rhubarb' ,   'pie' ,   1 )  # -- check that the fields exist and have the correct value  assert   a . bar   ==   'pie'  assert   a . baz   ==   1  assert   a . verbose   ==   False  # -- check that a non-included field does not exist  print ( a . foo ) # raises AttributeError    Explicit list of names to exclude:   class   C ( object ): \n     @autoargs ( exclude = ( 'bar' ,   'baz' ,   'verbose' )) \n     def   __init__ ( self ,   foo ,   bar ,   baz ,   verbose = False ): \n         pass  # Test :   # -- create an instance  a   =   C ( 'rhubarb' ,   'pie' ,   1 )  # -- check that the fields exist and have the correct value  assert   a . foo   ==   'rhubarb'  # -- check that the non-included fields do not exist  print ( a . bar )    # raises AttributeError  print ( a . baz )    # raises AttributeError  print ( a . verbose )    # raises AttributeError",
            "title": "@autoargs"
        },
        {
            "location": "/usage/#autoprops",
            "text": "Automatically generates all properties getters and setters from the class constructor.   Basic functionality, no customization - all constructor arguments become properties:    @autoprops  class   FooConfigA ( object ): \n\n     @autoargs \n     def   __init__ ( self ,   a :   str ,   b :   List [ str ]): \n         pass  t   =   FooConfigA ( 'rhubarb' ,   [ 'pie' ,   'pie2' ])  # there are no contracts on the generated setters  t . a = ''  t . b = [ 'r' , '' ]  # check that the generated getters work  assert   t . a   ==   ''  assert   t . b [ 0 ]   ==   'r'    if a  PyContracts   @contract  annotation exist on the  __init__  method, mentioning a contract for a given parameter, the\nparameter contract will be added on the generated setter method:   from   contracts   import   ContractNotRespected ,   contract  @autoprops  class   FooConfigA ( object ): \n\n     @autoargs \n     @contract ( a = 'str[>0]' ,   b = 'list[>0](str[>0])' ) \n     def   __init__ ( self ,   a :   str ,   b :   List [ str ]): \n         pass  t   =   FooConfigA ( 'rhubarb' ,   [ 'pie' ,   'pie2' ])  # check that the generated getters work  t . b = [ 'r' ]  assert   t . b [ 0 ]   ==   'r'  # check that there are contracts on the generated setters  t . a   =   ''    # raises ContractNotRespected  t . b   =   [ 'r' , '' ]    # raises ContractNotRespected    The user may override the generated getter and/or setter by creating them explicitly in the class and annotating\nthem with  @getter_override  or  @setter_override . Note that the contract will still be dynamically added on the setter, even if the setter already has one (in such case a  UserWarning  will be issued)   @autoprops  class   FooConfigC ( object ): \n\n     @autoargs \n     @contract ( a = 'str[>0]' ,   b = 'list[>0](str[>0])' ) \n     def   __init__ ( self ,   a :   str ,   b :   List [ str ]): \n         pass \n\n     @getter_override \n     def   a ( self ): \n         # in addition to getting the fields we'd like to print something \n         print ( 'a is being read. Its value is  \\' '   +   str ( self . _a )   +   ' \\' ' ) \n         return   self . _a \n\n     @setter_override ( attribute = 'b' ) \n     def   another_name ( self ,   toto :   List [ str ]): \n         # in addition to setting the fields we'd like to print something \n         print ( 'Property  \\' b \\'  was set to  \\' '   +   str ( toto )   +   ' \\' ' ) \n         self . _b   =   toto  t   =   FooConfigC ( 'rhubarb' ,   [ 'pie' ,   'pie2' ])  # check that we can still read a's value  assert   t . a   ==   'rhubarb'  # check that 'b' still has a getter generated  t . b   =   [ 'eh' ,   'oh' ]  assert   t . b   ==   [ 'eh' ,   'oh' ]  # check that 'a' still has a contract on its setter  t . a   =   ''    # raises ContractNotRespected  # check that 'b' still has a contract on its setter  t . b = [ '' ]    # raises ContractNotRespected    Note: you may also perform the same action without decorator, using  autoprops_decorate(cls) .   # we don't use @autoprops here  class   FooConfigA ( object ): \n     @autoargs \n     @contract ( a = 'str[>0]' ,   b = 'list[>0](str[>0])' ) \n     def   __init__ ( self ,   a :   str ,   b :   List [ str ]): \n         pass  # we execute it here  autoprops_decorate ( FooConfigA )  t   =   FooConfigA ( 'rhubarb' ,   [ 'pie' ,   'pie2' ])  # check that the generated getters work  t . b   =   [ 'r' ]  assert   t . b [ 0 ]   ==   'r'  # check that there are contracts on the generated setters  t . a   =   ''    # raises ContractNotRespected  t . b   =   [ 'r' , '' ]    # raises ContractNotRespected",
            "title": "@autoprops"
        }
    ]
}