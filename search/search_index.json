{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-autoclass \u00b6 Write compact python classes autoclass is now fully compliant with pyfields ! Check out how you can create very compact classes here autoclass provides tools to automatically generate python classes code. The objective of this library is to reduce the amount of redundancy by automatically generating parts of the code from the information already available somewhere else (in the constructor signature or in the pyfields fields for example). It is made of several independent features that can be combined: with @autoargs you don't have to write self.xxx = xxx in your constructor with @autoprops all or part your constructor arguments become properties and their setter is annotated with the same PEP484 type hints and value validation methods with @autohash , your object is hashable based on the tuple of all fields (so it can be used as a dictionary key or put in a set) with @autodict , your object behaves like a dictionary, is comparable with dictionaries, and gets a string representation with @autorepr , your object gets a string representation (use either this or @autodict , not both at the same time) with @autoclass , you get all of the above at once (but you can still disable some of them) The intent is similar to attrs and PEP557 dataclasses : remove boilerplate code. However as opposed to these, this library can be applied on any class. It does not change anything in your coding habits: you can still create a __init__ constructor, and everything else is provided with decorators. if information about fields is available from another library, autoclass can easily leverage it : for example you can now use pyfields to declare the fields, autoclass will support it. all decorators above can be used independently, for example if you just need to add a dictionary behaviour to an existing class you can use @autodict only. all created code is simple and readable. You can easily step through the generated functions in debug mode to understand what's going on as opposed to attrs , setters are generated for the fields so validation libraries such as valid8 can wrap them. Alternatively if you use pyfields , it directly provides this feature. In other words, autoclass simply generates the same code that you would have written manually. For this reason, in many cases you can use other libraries on top of the resulting classes without hassle. A good example is that you can use any PEP484 type checking library of your choice. Installing \u00b6 > pip install autoclass You may wish to also install pyfields to create compact classes. a PEP484-based type checker: typeguard , pytypes or enforce . a value validator: valid8 was originally created in this project and is now independent. Alternatively, you may use PyContracts to perform type and value validation at the same time using @contract , but this will not benefit from PEP484 and uses a dedicated syntax. This documentation also shows some examples. > pip install pyfields > pip install pytypes > pip install valid8 > pip install PyContracts 1. Basic usage \u00b6 The following code shows how you define a House with two attributes name and nb_floors : from autoclass import autoclass @autoclass class House : def __init__ ( self , name , nb_floors = 1 ): pass That's it ! By default you get that the constructor is filled automatically, a \"dictionary\" behaviour is added to the class, a string representation of objects is available, and objects are comparable (equality) and hashable: >>> obj = House ( 'my_house' , 3 ) >>> print ( obj ) # string representation House ( name = 'my_house' , nb_floors = 3 ) >>> [ att for att in obj.keys ()] # dictionary behaviour [ 'name' , 'nb_floors' ] >>> assert { obj, obj } == { obj } # hashable: can be used in a set or as a dict key >>> assert obj == House ( 'my_house' , 3 ) # comparison (equality) >>> assert obj == { 'name' : 'my_house' , 'nb_floors' : 3 } # comparison with dicts If you wish to add some behaviour (custom logic, logging...) when attributes are accessed or set, you can easily override the generated getters and setters. For example, below we will print a message everytime nb_floors is set: from autoclass import autoclass , setter_override @autoclass class House : def __init__ ( self , name , nb_floors = 1 ): pass @setter_override def nb_floors ( self , nb_floors = 1 ): print ( 'Set nb_floors to {} ' . format ( nb_floors )) self . _nb_floors = nb_floors We can test it: >>> obj = House ( 'my_house' ) Set nb_floors to 1 >>> obj.nb_floors = 3 Set nb_floors to 3 pyfields combo \u00b6 If you already use pyfields to define mandatory/optional fields with type/value validation, simply decorate your class with @autoclass and you'll get all of the above (dict view, hashability, string representation, equality...) too: from pyfields import field from autoclass import autoclass from mini_lambda import x @autoclass class House : name : str = field ( check_type = True , doc = \"the name of your house\" ) nb_floors : int = field ( default = 1 , check_type = True , doc = \"the nb floors\" , validators = { \"should be positive\" : x >= 0 , \"should be a multiple of 100\" : x % 100 == 0 }) Indeed behind the scenes, if autoclass detects that your class uses pyfields , it will automatically use the fields rather than the constructor signature to get the list of fields. You can check that all the features are there: >>> obj = House ( 'my_house' , 200 ) >>> print ( obj ) # string representation House ( name = 'my_house' , nb_floors = 200 ) >>> [ att for att in obj.keys ()] # dictionary behaviour [ 'name' , 'nb_floors' ] >>> assert { obj, obj } == { obj } # hashable: can be used in a set or as a dict key >>> assert obj == House ( 'my_house' , 200 ) # comparison (equality) >>> assert obj == { 'name' : 'my_house' , 'nb_floors' : 200 } # comparison with dicts Note: this works with python 2.7, and 3.5+. See pyfields documentation for details. 2. Type and Value validation \u00b6 If you do not use pyfields , then you might be interested to add type and value validation to your fields through another means. a- PEP484 Type validation \u00b6 enforce \u00b6 PEP484 is the standard for inserting python type hint in function signatures, starting from python 3.5 (a backport is available through the independent typing module). Many compliant type checkers are now available such as enforce or pytypes . If you decorate your class constructor with PEP484 type hints, then autoclass detects it and will automatically decorate the generated property getters and setters. We use enforce runtime checker in this example: from autoclass import autoclass from enforce import runtime_validation @runtime_validation @autoclass class House : # the constructor below is decorated with PEP484 type hints def __init__ ( self , name : str , nb_floors : int = 1 ): pass We can test it: >>> obj = House ( 'my_house' ) >>> obj.nb_floors = 'red' enforce.exceptions.RuntimeTypeError: The following runtime type errors were encountered: Argument 'nb_floors' was not of type <class 'int' >. Actual type was str. See enforce documentation for details. pytypes \u00b6 Below is the same example, but with pytypes instead of enforce : from autoclass import autoclass from pytypes import typechecked @typechecked @autoclass class House : # the constructor below is decorated with PEP484 type hints def __init__ ( self , name : str , nb_floors : int = 1 ): pass typeguard \u00b6 TODO b- Simple Type+Value validation \u00b6 valid8 \u00b6 valid8 was originally created in this project and is now independent. It provides mainly value validation, but also basic type validation. With valid8 , in order to add validation to any function, you simply decorate that function with @validate_arg , possibly providing custom error types to raise: from valid8 import validate_arg @validate_arg ( 'foo' , < validation functions > , error_type = MyErrorType ) def my_func ( foo ): ... Now if you decorate your class constructor with @validate_arg , then autoclass detects it and will automatically decorate the generated property setters too. from autoclass import autoclass from mini_lambda import s , x , Len from valid8 import validate_arg , InputValidationError from valid8.validation_lib import instance_of , is_multiple_of # 2 custom validation errors for valid8 class InvalidName ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurface ( InputValidationError ): help_msg = 'Surface should be between 0 and 10000 and be a multiple of 100.' @autoclass class House : @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidName ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurface ) def __init__ ( self , name , surface = None ): pass We can test it: >>> obj = House ( 'sweet home' , 200 ) >>> obj.surface = None # Valid (surface is nonable by signature) >>> obj.name = 12 # Type validation InvalidName: name should be a non-empty string. >>> obj.surface = 10000 # Value validation InvalidSurface: Surface should be between 0 and 10000 and be a multiple of 100 . See valid8 documentation for details. Note that other validation libraries relying on the same principles could probably be supported easily, please create an issue to suggest some ! PyContracts \u00b6 PyContracts is also supported: from autoclass import autoclass from contracts import contract @autoclass class House : @contract ( name = 'str[>0]' , surface = 'None|(int,>=0,<10000)' ) def __init__ ( self , name , surface ): pass c- PEP484 Type+Value validation \u00b6 Finally, in real-world applications you might wish to combine both PEP484 type checking and value validation. This works as expected, for example with enforce and valid8 : from autoclass import autoclass # Imports - for type validation from numbers import Integral from enforce import runtime_validation , config config ( dict ( mode = 'covariant' )) # type validation will accept subclasses too # Imports - for value validation from mini_lambda import s , x , Len from valid8 import validate_arg , InputValidationError from valid8.validation_lib import is_multiple_of # 2 custom validation errors for valid8 class InvalidName ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurface ( InputValidationError ): help_msg = 'Surface should be between 0 and 10000 and be a multiple of 100.' @runtime_validation @autoclass class House : @validate_arg ( 'name' , Len ( s ) > 0 , error_type = InvalidName ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurface ) def __init__ ( self , name : str , surface : Integral = None ): pass We can test that validation works: >>> obj = House ( 'sweet home' , 200 ) >>> obj.surface = None # Valid (surface is nonable by signature) >>> obj.name = 12 # Type validation > PEP484 enforce.exceptions.RuntimeTypeError: The following runtime type errors were encountered: Argument 'name' was not of type <class 'str' >. Actual type was int. >>> obj.surface = 10000 # Value validation > valid8 InvalidSurface: Surface should be between 0 and 10000 and be a multiple of 100 . Why autoclass ? \u00b6 Python's primitive types (in particular dict and tuple ) and it's dynamic typing system make it extremely powerful, to the point that it is often more convenient for developers to use primitive types or generic dynamic objects such as Munch , rather than small custom classes. However there are certain cases where developers still want to define their own classes, for example to provide strongly-typed APIs to their clients. In such case, separation of concerns will typically lead developers to enforce attribute value validation directly in the class, rather than in the code using the object. Eventually developers end up with big classes like this one: from valid8 import validate , Boolean from numbers import Real , Integral from typing import Optional , Union class House : def __init__ ( self , name : str , surface : Real , nb_floors : Optional [ Integral ] = 1 , with_windows : Boolean = False ): self . name = name self . surface = surface self . nb_floors = nb_floors self . with_windows = with_windows # --name @property def name ( self ): return self . _name @name . setter def name ( self , name : str ): validate ( 'name' , name , instance_of = str ) self . _name = name # --surface @property def surface ( self ) -> Real : return self . _surface @surface . setter def surface ( self , surface : Real ): validate ( 'surface' , surface , instance_of = Real , min_value = 0 , min_strict = True ) self . _surface = surface # --nb_floors @property def nb_floors ( self ) -> Optional [ Integral ]: return self . _nb_floors @nb_floors . setter def nb_floors ( self , nb_floors : Optional [ Integral ]): validate ( 'nb_floors' , nb_floors , instance_of = Integral , enforce_not_none = False ) self . _surface = nb_floors # !** # --with_windows @property def with_windows ( self ) -> Boolean : return self . _with_windows @with_windows . setter def with_windows ( self , with_windows : Boolean ): validate ( 'with_windows' , with_windows , instance_of = Boolean ) self . _with_windows = with_windows Not to mention extra methods such as __str__ , __eq__ , from_dict , to_dict ... Now that's a lot of code - and only for 4 attributes ! Not mentioning the code for validate that was not included here for the sake of readability. And guess what - it is still highly prone to human mistakes . For example I made a mistake in the setter for nb_floors , did you spot it ? Also it makes the code less readable : did you spot that the setter for the surface property is different from the others? Really, \"there must be a better way\" : yes there is, and that's what this library provides. Main features \u00b6 @autoargs is a decorator for the __init__ method of a class. It automatically assigns all of the __init__ method's parameters to self . For more fine-grain tuning, explicit inclusion and exclusion lists are supported, too. Note: the original @autoargs idea and code come from this answer from utnubu @autoprops is a decorator for a whole class. It automatically generates properties getters and setters for all attributes, with the correct PEP484 type hints. As for @autoargs , the default list of attributes is the list of parameters of the __init__ method, and explicit inclusion and exclusion lists are supported. @autoprops automatically adds @contract ( PyContracts ) or @validate_arg (from valid8 ) on the generated setters if a @contract or @validate_arg exists for that attribute on the __init__ method. @autoprops -generated getters and setters are fully PEP484 decorated so that type checkers like enforce automatically apply to generated methods when used to decorate the whole class. No explicit integration needed in autoclass! You may override the getter or setter generated by @autoprops using @getter_override and @setter_override . Note that the @contract and @validate will still be added on your custom setter if present on __init__ , you don't have to repeat it yourself @autodict is a decorator for a whole class. It makes a class behave like a (read-only) dict, with control on which attributes are visible in that dictionary. So this is a 'dict view' on top of an object, basically the opposite of munch (that is an 'object view' on top of a dict). It automatically implements __eq__ , __str__ and __repr__ if they are not present already. @autohash is a decorator for a whole class. It makes the class hashable by implementing __hash__ if not already present, where the hash is computed from the tuple of selected fields (all by default, customizable). @autorepr is a decorator for a whole class. It adds a string representation by implementing __str__ and __repr__ if not already present. Equivalent manual wrapper methods are provided for all decorators in this library: autoargs_decorate(init_func, include, exclude) autoprops_decorate(cls, include, exclude) autoprops_override_decorate(func, attribute, is_getter) autodict_decorate(cls, include, exclude, only_known_fields, only_public_fields) autohash_decorate(cls, include, exclude, only_known_fields, only_public_fields) autorepr_decorate(cls, include, exclude, only_known_fields, only_public_fields) See Also \u00b6 Initial idea of autoargs : this answer from utnubu On properties in Python and why you should only use them if you really need to (for example, to perform validation by contract): Python is not java and the follow up article Getters/Setters/Fuxors PyContracts PEP484-based checkers: enforce pytypes typeguard typecheck-decorator attrs is a library with the same target, but the way to use it is quite different from 'standard' python. It is very powerful and elegant, though. The new PEP out there, largely inspired by attrs : PEP557 . Check it out! There is also a discussion on python-ideas . decorator library, which provides everything one needs to create complex decorators easily (signature and annotations-preserving decorators, decorators with class factory) as well as provides some useful decorators ( @contextmanager , @blocking , @dispatch_on ). We used it to preserve the signature of class constructors and overriden setter methods. Now we use makefun instead, which was inspired by it. When came the time to find a name for this library I was stuck for a while. In my quest for finding an explicit name that was not already used, I found many interesting libraries on PyPI . I did not test them all but found them 'good to know': decorator-args classtools classutils python-utils utils Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-autoclass","title":"Home"},{"location":"#python-autoclass","text":"Write compact python classes autoclass is now fully compliant with pyfields ! Check out how you can create very compact classes here autoclass provides tools to automatically generate python classes code. The objective of this library is to reduce the amount of redundancy by automatically generating parts of the code from the information already available somewhere else (in the constructor signature or in the pyfields fields for example). It is made of several independent features that can be combined: with @autoargs you don't have to write self.xxx = xxx in your constructor with @autoprops all or part your constructor arguments become properties and their setter is annotated with the same PEP484 type hints and value validation methods with @autohash , your object is hashable based on the tuple of all fields (so it can be used as a dictionary key or put in a set) with @autodict , your object behaves like a dictionary, is comparable with dictionaries, and gets a string representation with @autorepr , your object gets a string representation (use either this or @autodict , not both at the same time) with @autoclass , you get all of the above at once (but you can still disable some of them) The intent is similar to attrs and PEP557 dataclasses : remove boilerplate code. However as opposed to these, this library can be applied on any class. It does not change anything in your coding habits: you can still create a __init__ constructor, and everything else is provided with decorators. if information about fields is available from another library, autoclass can easily leverage it : for example you can now use pyfields to declare the fields, autoclass will support it. all decorators above can be used independently, for example if you just need to add a dictionary behaviour to an existing class you can use @autodict only. all created code is simple and readable. You can easily step through the generated functions in debug mode to understand what's going on as opposed to attrs , setters are generated for the fields so validation libraries such as valid8 can wrap them. Alternatively if you use pyfields , it directly provides this feature. In other words, autoclass simply generates the same code that you would have written manually. For this reason, in many cases you can use other libraries on top of the resulting classes without hassle. A good example is that you can use any PEP484 type checking library of your choice.","title":"python-autoclass"},{"location":"#installing","text":"> pip install autoclass You may wish to also install pyfields to create compact classes. a PEP484-based type checker: typeguard , pytypes or enforce . a value validator: valid8 was originally created in this project and is now independent. Alternatively, you may use PyContracts to perform type and value validation at the same time using @contract , but this will not benefit from PEP484 and uses a dedicated syntax. This documentation also shows some examples. > pip install pyfields > pip install pytypes > pip install valid8 > pip install PyContracts","title":"Installing"},{"location":"#1-basic-usage","text":"The following code shows how you define a House with two attributes name and nb_floors : from autoclass import autoclass @autoclass class House : def __init__ ( self , name , nb_floors = 1 ): pass That's it ! By default you get that the constructor is filled automatically, a \"dictionary\" behaviour is added to the class, a string representation of objects is available, and objects are comparable (equality) and hashable: >>> obj = House ( 'my_house' , 3 ) >>> print ( obj ) # string representation House ( name = 'my_house' , nb_floors = 3 ) >>> [ att for att in obj.keys ()] # dictionary behaviour [ 'name' , 'nb_floors' ] >>> assert { obj, obj } == { obj } # hashable: can be used in a set or as a dict key >>> assert obj == House ( 'my_house' , 3 ) # comparison (equality) >>> assert obj == { 'name' : 'my_house' , 'nb_floors' : 3 } # comparison with dicts If you wish to add some behaviour (custom logic, logging...) when attributes are accessed or set, you can easily override the generated getters and setters. For example, below we will print a message everytime nb_floors is set: from autoclass import autoclass , setter_override @autoclass class House : def __init__ ( self , name , nb_floors = 1 ): pass @setter_override def nb_floors ( self , nb_floors = 1 ): print ( 'Set nb_floors to {} ' . format ( nb_floors )) self . _nb_floors = nb_floors We can test it: >>> obj = House ( 'my_house' ) Set nb_floors to 1 >>> obj.nb_floors = 3 Set nb_floors to 3","title":"1. Basic usage"},{"location":"#pyfields-combo","text":"If you already use pyfields to define mandatory/optional fields with type/value validation, simply decorate your class with @autoclass and you'll get all of the above (dict view, hashability, string representation, equality...) too: from pyfields import field from autoclass import autoclass from mini_lambda import x @autoclass class House : name : str = field ( check_type = True , doc = \"the name of your house\" ) nb_floors : int = field ( default = 1 , check_type = True , doc = \"the nb floors\" , validators = { \"should be positive\" : x >= 0 , \"should be a multiple of 100\" : x % 100 == 0 }) Indeed behind the scenes, if autoclass detects that your class uses pyfields , it will automatically use the fields rather than the constructor signature to get the list of fields. You can check that all the features are there: >>> obj = House ( 'my_house' , 200 ) >>> print ( obj ) # string representation House ( name = 'my_house' , nb_floors = 200 ) >>> [ att for att in obj.keys ()] # dictionary behaviour [ 'name' , 'nb_floors' ] >>> assert { obj, obj } == { obj } # hashable: can be used in a set or as a dict key >>> assert obj == House ( 'my_house' , 200 ) # comparison (equality) >>> assert obj == { 'name' : 'my_house' , 'nb_floors' : 200 } # comparison with dicts Note: this works with python 2.7, and 3.5+. See pyfields documentation for details.","title":"pyfields combo"},{"location":"#2-type-and-value-validation","text":"If you do not use pyfields , then you might be interested to add type and value validation to your fields through another means.","title":"2. Type and Value validation"},{"location":"#a-pep484-type-validation","text":"","title":"a- PEP484 Type validation"},{"location":"#enforce","text":"PEP484 is the standard for inserting python type hint in function signatures, starting from python 3.5 (a backport is available through the independent typing module). Many compliant type checkers are now available such as enforce or pytypes . If you decorate your class constructor with PEP484 type hints, then autoclass detects it and will automatically decorate the generated property getters and setters. We use enforce runtime checker in this example: from autoclass import autoclass from enforce import runtime_validation @runtime_validation @autoclass class House : # the constructor below is decorated with PEP484 type hints def __init__ ( self , name : str , nb_floors : int = 1 ): pass We can test it: >>> obj = House ( 'my_house' ) >>> obj.nb_floors = 'red' enforce.exceptions.RuntimeTypeError: The following runtime type errors were encountered: Argument 'nb_floors' was not of type <class 'int' >. Actual type was str. See enforce documentation for details.","title":"enforce"},{"location":"#pytypes","text":"Below is the same example, but with pytypes instead of enforce : from autoclass import autoclass from pytypes import typechecked @typechecked @autoclass class House : # the constructor below is decorated with PEP484 type hints def __init__ ( self , name : str , nb_floors : int = 1 ): pass","title":"pytypes"},{"location":"#typeguard","text":"TODO","title":"typeguard"},{"location":"#b-simple-typevalue-validation","text":"","title":"b- Simple Type+Value validation"},{"location":"#valid8","text":"valid8 was originally created in this project and is now independent. It provides mainly value validation, but also basic type validation. With valid8 , in order to add validation to any function, you simply decorate that function with @validate_arg , possibly providing custom error types to raise: from valid8 import validate_arg @validate_arg ( 'foo' , < validation functions > , error_type = MyErrorType ) def my_func ( foo ): ... Now if you decorate your class constructor with @validate_arg , then autoclass detects it and will automatically decorate the generated property setters too. from autoclass import autoclass from mini_lambda import s , x , Len from valid8 import validate_arg , InputValidationError from valid8.validation_lib import instance_of , is_multiple_of # 2 custom validation errors for valid8 class InvalidName ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurface ( InputValidationError ): help_msg = 'Surface should be between 0 and 10000 and be a multiple of 100.' @autoclass class House : @validate_arg ( 'name' , instance_of ( str ), Len ( s ) > 0 , error_type = InvalidName ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurface ) def __init__ ( self , name , surface = None ): pass We can test it: >>> obj = House ( 'sweet home' , 200 ) >>> obj.surface = None # Valid (surface is nonable by signature) >>> obj.name = 12 # Type validation InvalidName: name should be a non-empty string. >>> obj.surface = 10000 # Value validation InvalidSurface: Surface should be between 0 and 10000 and be a multiple of 100 . See valid8 documentation for details. Note that other validation libraries relying on the same principles could probably be supported easily, please create an issue to suggest some !","title":"valid8"},{"location":"#pycontracts","text":"PyContracts is also supported: from autoclass import autoclass from contracts import contract @autoclass class House : @contract ( name = 'str[>0]' , surface = 'None|(int,>=0,<10000)' ) def __init__ ( self , name , surface ): pass","title":"PyContracts"},{"location":"#c-pep484-typevalue-validation","text":"Finally, in real-world applications you might wish to combine both PEP484 type checking and value validation. This works as expected, for example with enforce and valid8 : from autoclass import autoclass # Imports - for type validation from numbers import Integral from enforce import runtime_validation , config config ( dict ( mode = 'covariant' )) # type validation will accept subclasses too # Imports - for value validation from mini_lambda import s , x , Len from valid8 import validate_arg , InputValidationError from valid8.validation_lib import is_multiple_of # 2 custom validation errors for valid8 class InvalidName ( InputValidationError ): help_msg = 'name should be a non-empty string' class InvalidSurface ( InputValidationError ): help_msg = 'Surface should be between 0 and 10000 and be a multiple of 100.' @runtime_validation @autoclass class House : @validate_arg ( 'name' , Len ( s ) > 0 , error_type = InvalidName ) @validate_arg ( 'surface' , ( x >= 0 ) & ( x < 10000 ), is_multiple_of ( 100 ), error_type = InvalidSurface ) def __init__ ( self , name : str , surface : Integral = None ): pass We can test that validation works: >>> obj = House ( 'sweet home' , 200 ) >>> obj.surface = None # Valid (surface is nonable by signature) >>> obj.name = 12 # Type validation > PEP484 enforce.exceptions.RuntimeTypeError: The following runtime type errors were encountered: Argument 'name' was not of type <class 'str' >. Actual type was int. >>> obj.surface = 10000 # Value validation > valid8 InvalidSurface: Surface should be between 0 and 10000 and be a multiple of 100 .","title":"c- PEP484 Type+Value validation"},{"location":"#why-autoclass","text":"Python's primitive types (in particular dict and tuple ) and it's dynamic typing system make it extremely powerful, to the point that it is often more convenient for developers to use primitive types or generic dynamic objects such as Munch , rather than small custom classes. However there are certain cases where developers still want to define their own classes, for example to provide strongly-typed APIs to their clients. In such case, separation of concerns will typically lead developers to enforce attribute value validation directly in the class, rather than in the code using the object. Eventually developers end up with big classes like this one: from valid8 import validate , Boolean from numbers import Real , Integral from typing import Optional , Union class House : def __init__ ( self , name : str , surface : Real , nb_floors : Optional [ Integral ] = 1 , with_windows : Boolean = False ): self . name = name self . surface = surface self . nb_floors = nb_floors self . with_windows = with_windows # --name @property def name ( self ): return self . _name @name . setter def name ( self , name : str ): validate ( 'name' , name , instance_of = str ) self . _name = name # --surface @property def surface ( self ) -> Real : return self . _surface @surface . setter def surface ( self , surface : Real ): validate ( 'surface' , surface , instance_of = Real , min_value = 0 , min_strict = True ) self . _surface = surface # --nb_floors @property def nb_floors ( self ) -> Optional [ Integral ]: return self . _nb_floors @nb_floors . setter def nb_floors ( self , nb_floors : Optional [ Integral ]): validate ( 'nb_floors' , nb_floors , instance_of = Integral , enforce_not_none = False ) self . _surface = nb_floors # !** # --with_windows @property def with_windows ( self ) -> Boolean : return self . _with_windows @with_windows . setter def with_windows ( self , with_windows : Boolean ): validate ( 'with_windows' , with_windows , instance_of = Boolean ) self . _with_windows = with_windows Not to mention extra methods such as __str__ , __eq__ , from_dict , to_dict ... Now that's a lot of code - and only for 4 attributes ! Not mentioning the code for validate that was not included here for the sake of readability. And guess what - it is still highly prone to human mistakes . For example I made a mistake in the setter for nb_floors , did you spot it ? Also it makes the code less readable : did you spot that the setter for the surface property is different from the others? Really, \"there must be a better way\" : yes there is, and that's what this library provides.","title":"Why autoclass ?"},{"location":"#main-features","text":"@autoargs is a decorator for the __init__ method of a class. It automatically assigns all of the __init__ method's parameters to self . For more fine-grain tuning, explicit inclusion and exclusion lists are supported, too. Note: the original @autoargs idea and code come from this answer from utnubu @autoprops is a decorator for a whole class. It automatically generates properties getters and setters for all attributes, with the correct PEP484 type hints. As for @autoargs , the default list of attributes is the list of parameters of the __init__ method, and explicit inclusion and exclusion lists are supported. @autoprops automatically adds @contract ( PyContracts ) or @validate_arg (from valid8 ) on the generated setters if a @contract or @validate_arg exists for that attribute on the __init__ method. @autoprops -generated getters and setters are fully PEP484 decorated so that type checkers like enforce automatically apply to generated methods when used to decorate the whole class. No explicit integration needed in autoclass! You may override the getter or setter generated by @autoprops using @getter_override and @setter_override . Note that the @contract and @validate will still be added on your custom setter if present on __init__ , you don't have to repeat it yourself @autodict is a decorator for a whole class. It makes a class behave like a (read-only) dict, with control on which attributes are visible in that dictionary. So this is a 'dict view' on top of an object, basically the opposite of munch (that is an 'object view' on top of a dict). It automatically implements __eq__ , __str__ and __repr__ if they are not present already. @autohash is a decorator for a whole class. It makes the class hashable by implementing __hash__ if not already present, where the hash is computed from the tuple of selected fields (all by default, customizable). @autorepr is a decorator for a whole class. It adds a string representation by implementing __str__ and __repr__ if not already present. Equivalent manual wrapper methods are provided for all decorators in this library: autoargs_decorate(init_func, include, exclude) autoprops_decorate(cls, include, exclude) autoprops_override_decorate(func, attribute, is_getter) autodict_decorate(cls, include, exclude, only_known_fields, only_public_fields) autohash_decorate(cls, include, exclude, only_known_fields, only_public_fields) autorepr_decorate(cls, include, exclude, only_known_fields, only_public_fields)","title":"Main features"},{"location":"#see-also","text":"Initial idea of autoargs : this answer from utnubu On properties in Python and why you should only use them if you really need to (for example, to perform validation by contract): Python is not java and the follow up article Getters/Setters/Fuxors PyContracts PEP484-based checkers: enforce pytypes typeguard typecheck-decorator attrs is a library with the same target, but the way to use it is quite different from 'standard' python. It is very powerful and elegant, though. The new PEP out there, largely inspired by attrs : PEP557 . Check it out! There is also a discussion on python-ideas . decorator library, which provides everything one needs to create complex decorators easily (signature and annotations-preserving decorators, decorators with class factory) as well as provides some useful decorators ( @contextmanager , @blocking , @dispatch_on ). We used it to preserve the signature of class constructors and overriden setter methods. Now we use makefun instead, which was inspired by it. When came the time to find a name for this library I was stuck for a while. In my quest for finding an explicit name that was not already used, I found many interesting libraries on PyPI . I did not test them all but found them 'good to know': decorator-args classtools classutils python-utils utils Do you like this library ? You might also like my other python libraries","title":"See Also"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-autoclass","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 2.1.5 - python 2 packaging improvements \u00b6 setup improvements: set the universal wheel flag to 1, and cleaned up the setup.py. Fixes #36 2.1.4 - Packaging improvements \u00b6 setup.py improvements: now including py.typed , excluding tests folder, and using zip_safe=False 2.1.3 - Fixed DeprecationWarning \u00b6 Fixed DeprecationWarning. Fixed #35 2.1.2 - bugfix \u00b6 Fixed bug happening when pyfields is not installed. Fixed #33 . 2.1.1 - pyproject.toml \u00b6 Added pyproject.toml . 2.1.0 - @autoeq \u00b6 Features Added independent @autoeq , supported in @autoclass and automatically activated when autodict=False . Fixed #32 . Bugfixes Fixed @autorepr when only_known_fields is False : now property names are correctly used instead of the private names. Fixed @autodict 's generated __eq__ method: when the other object is a dictionary a direct comparison is now done before trying super. 2.0.0 - pyfields support + major refactoring \u00b6 Features default string representation in @autodict is now more readable. Legacy representation is still available through a parameter. Fixed #29 . pyfields can now be used as the source for the list of attributes, in @autohash , @autodict , and @autoclass . Fixes #28 new @autorepr decorator. Previously this feature was only available through @autodict , it can now be used without it. autorepr is supported in @autoclass , and if users set autodict=False by default it will be enabled. Fixed Fixed #30 and #31 . Misc / bugfixes Major refactoring: more readable and maintainable code. Fixed @autodict behaviour when the list was vars(self) and used together with @autoprops : with some options the private names were appearing and with others the public property names were appearing. Now the public property names always appear if they exist. 1.18.0 - @autoslots \u00b6 New @autoslots feature, that can also be used from @autoclass by setting (autoslots=True) . Fixes #9 1.17.2 - Added __version__ attribute \u00b6 Added __version__ attribute at package level. 1.17.1 - Fixed bug with latest valid8 \u00b6 Fixed ValidationError happening in all use cases. Fixed #25 . 1.17.0 - Fixed include / exclude behaviour concerning property attributes \u00b6 Names used in include and exclude are now correctly taken into account by autodict and autohash even if the names correspond to property names and therefore the actual attributes names start with an underscore. Fixes #21 1.16.0 - Python 2 support \u00b6 This library now works on python 2.7, 3.5, 3.6 and 3.7. Fixes #3 . 1.15.1 - fixed valid8 exception message \u00b6 Fixed #24 1.15.0 - more tolerance for inherited constructors \u00b6 autodict , autohash and autoprops now tolerate inherited constructors 1.14.0 - submodule name changes \u00b6 The submodule names were conflicting with the variable names: renamed them all The init file has been improved so as not to export symbols from other packages. Fixes #23 1.13.0 - @autodict_override \u00b6 New annotation @autodict_override that you can use to override __iter__ , __getitem__ or __len__ . Fixes #22 1.12.0 - autodict fix \u00b6 In case of inheritance, the order of attributes in now better and reproductible. Fixes #20 Printed representation created by @autodict now uses the same order than the generated keys iterator on the dictionary-faceted object. 1.11.0 - autodict fixes \u00b6 @autodict does not add the from_dict class method anymore if this method already exists. If it does not already exist however, it is now always created (even if only_constructor_args=False ) inheritance is now handled more correctly (not perfect but it seems to handle more cases) with @autodict . Fixes #19 1.10.2 - minor bugfix \u00b6 Fixed #18 1.10.1 - compatibility \u00b6 Now compliant with old versions of typing module: typing.Type is not imported explicitly anymore. tests updated with latest version of valid8 1.10.0 - bugfixes and updated doc \u00b6 Updated documentation main page @autoargs behaviour wrt keyword arguments changed. See usage page for details. include and exclude parameters now support any kind of sequence, in all decorators Bugfix: Setter is called twice for default values Bugfix: @autoprops argument name in setter is not correct 1.9.2 - added autohash + fix \u00b6 new annotation @autohash The equality method __eq__ generated by @autodict is now correct @autodict : fixed consistency with default values of only_public_fields : it was False when using the individual decorator, but True when using @autoclass global decorator or the manual decoration method. Now it is True everywhere. 1.9.1 - a few fixes \u00b6 Now compliant with valid8 2.0.0 Fixed #13: now generated setters have default values when it was the case on the constructor. 1.9.0 - valid8 is now an independent project \u00b6 Boolean , validate , validate_decorate and all validators have been moved to an independent project, thus decoupling autoclass from the choice of validator library. 1.8.1 - minor improvements \u00b6 Now detecting conflicts with enforce when annotations are not in the right order (see #12 ) Added tests for on_each_ and on_all_ and fixed corresponding bugs. 1.8.0 - new validators for collections \u00b6 Added on_each_ and on_all_ 1.7.1 - bug fix: lts validator \u00b6 lts was erroneously mappend onto gt . Fixed this. 1.7.0 - @autoclass \u00b6 New decorator @autoclass to apply several features at once. @autodict now also generates a from_dict static method in the class, as well as __str__ , __repr__ and __eq__ if not present 1.6.0 - @autodict \u00b6 New decorator @autodict to make a class behave like a (read-only) dict. So this is a 'dict view' on top of an object, basically the opposite of munch (that is an 'object view' on top of a dict) 1.5.0 - Robustness and minor improvements \u00b6 better error messages for set enforcers uniform management of validators lists: now passing a list creates an 'and_' operator behind the scenes better handling of empty lists and, or, xor now automatically replace themselves with their contents when their contents is a single validator added a few tests to improve coverage (hopefully) 1.4.3 - User-friendly validators error messages \u00b6 better validation error messages for parametrized validators 1.4.2 - Improved and documented validators \u00b6 improved validators list documentation added new validator: and_ fixed bugs in or_ , not_ , and xor_ : since custom validators may now throw exceptions other than ValidationError and may return None , there was a need to update them to take these cases into account not_ may now be applied to a list of validators (implicit and_ ) more unit tests for boolean validators 1.4.1 - Improved and documented validation feature \u00b6 A validator function may now return None improved documentation on @validate in particular for custom validators implementation 1.4.0 - Added validation feature \u00b6 New: @validate annotation allowing to implement input validation. Comes with a bunch of built-in validators. 1.3.1 - Documentation and Travis integration 2 \u00b6 Improved documentation Automatic test report generation in travis Automatic PyPI deployment on tags in travis 1.3.0 - Project renaming \u00b6 classtools-autocode Project was renamed autoclass for clarity Travis configuration was updated accordingly 1.2.0 - Performance and documentation \u00b6 improved examples in the documentation improved performance of var_checker (lessons learnt from parsyfiles) 1.1.0 - Mkdocs and enforce \u00b6 now using mkdocs to generate the documentation from markdown @autoprops : generated getters and setters now have correct PEP484 signature, which makes the library compliant with enforce updated documentation accordingly 1.0.0 - First public working version with PyContracts \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#215-python-2-packaging-improvements","text":"setup improvements: set the universal wheel flag to 1, and cleaned up the setup.py. Fixes #36","title":"2.1.5 - python 2 packaging improvements"},{"location":"changelog/#214-packaging-improvements","text":"setup.py improvements: now including py.typed , excluding tests folder, and using zip_safe=False","title":"2.1.4 - Packaging improvements"},{"location":"changelog/#213-fixed-deprecationwarning","text":"Fixed DeprecationWarning. Fixed #35","title":"2.1.3 - Fixed DeprecationWarning"},{"location":"changelog/#212-bugfix","text":"Fixed bug happening when pyfields is not installed. Fixed #33 .","title":"2.1.2 - bugfix"},{"location":"changelog/#211-pyprojecttoml","text":"Added pyproject.toml .","title":"2.1.1 - pyproject.toml"},{"location":"changelog/#210-autoeq","text":"Features Added independent @autoeq , supported in @autoclass and automatically activated when autodict=False . Fixed #32 . Bugfixes Fixed @autorepr when only_known_fields is False : now property names are correctly used instead of the private names. Fixed @autodict 's generated __eq__ method: when the other object is a dictionary a direct comparison is now done before trying super.","title":"2.1.0 - @autoeq"},{"location":"changelog/#200-pyfields-support-major-refactoring","text":"Features default string representation in @autodict is now more readable. Legacy representation is still available through a parameter. Fixed #29 . pyfields can now be used as the source for the list of attributes, in @autohash , @autodict , and @autoclass . Fixes #28 new @autorepr decorator. Previously this feature was only available through @autodict , it can now be used without it. autorepr is supported in @autoclass , and if users set autodict=False by default it will be enabled. Fixed Fixed #30 and #31 . Misc / bugfixes Major refactoring: more readable and maintainable code. Fixed @autodict behaviour when the list was vars(self) and used together with @autoprops : with some options the private names were appearing and with others the public property names were appearing. Now the public property names always appear if they exist.","title":"2.0.0 - pyfields support + major refactoring"},{"location":"changelog/#1180-autoslots","text":"New @autoslots feature, that can also be used from @autoclass by setting (autoslots=True) . Fixes #9","title":"1.18.0 - @autoslots"},{"location":"changelog/#1172-added-__version__-attribute","text":"Added __version__ attribute at package level.","title":"1.17.2 - Added __version__ attribute"},{"location":"changelog/#1171-fixed-bug-with-latest-valid8","text":"Fixed ValidationError happening in all use cases. Fixed #25 .","title":"1.17.1 - Fixed bug with latest valid8"},{"location":"changelog/#1170-fixed-includeexclude-behaviour-concerning-property-attributes","text":"Names used in include and exclude are now correctly taken into account by autodict and autohash even if the names correspond to property names and therefore the actual attributes names start with an underscore. Fixes #21","title":"1.17.0 - Fixed include/exclude behaviour concerning property attributes"},{"location":"changelog/#1160-python-2-support","text":"This library now works on python 2.7, 3.5, 3.6 and 3.7. Fixes #3 .","title":"1.16.0 - Python 2 support"},{"location":"changelog/#1151-fixed-valid8-exception-message","text":"Fixed #24","title":"1.15.1 - fixed valid8 exception message"},{"location":"changelog/#1150-more-tolerance-for-inherited-constructors","text":"autodict , autohash and autoprops now tolerate inherited constructors","title":"1.15.0 - more tolerance for inherited constructors"},{"location":"changelog/#1140-submodule-name-changes","text":"The submodule names were conflicting with the variable names: renamed them all The init file has been improved so as not to export symbols from other packages. Fixes #23","title":"1.14.0 - submodule name changes"},{"location":"changelog/#1130-autodict_override","text":"New annotation @autodict_override that you can use to override __iter__ , __getitem__ or __len__ . Fixes #22","title":"1.13.0 - @autodict_override"},{"location":"changelog/#1120-autodict-fix","text":"In case of inheritance, the order of attributes in now better and reproductible. Fixes #20 Printed representation created by @autodict now uses the same order than the generated keys iterator on the dictionary-faceted object.","title":"1.12.0 - autodict fix"},{"location":"changelog/#1110-autodict-fixes","text":"@autodict does not add the from_dict class method anymore if this method already exists. If it does not already exist however, it is now always created (even if only_constructor_args=False ) inheritance is now handled more correctly (not perfect but it seems to handle more cases) with @autodict . Fixes #19","title":"1.11.0 - autodict fixes"},{"location":"changelog/#1102-minor-bugfix","text":"Fixed #18","title":"1.10.2 - minor bugfix"},{"location":"changelog/#1101-compatibility","text":"Now compliant with old versions of typing module: typing.Type is not imported explicitly anymore. tests updated with latest version of valid8","title":"1.10.1 - compatibility"},{"location":"changelog/#1100-bugfixes-and-updated-doc","text":"Updated documentation main page @autoargs behaviour wrt keyword arguments changed. See usage page for details. include and exclude parameters now support any kind of sequence, in all decorators Bugfix: Setter is called twice for default values Bugfix: @autoprops argument name in setter is not correct","title":"1.10.0 - bugfixes and updated doc"},{"location":"changelog/#192-added-autohash-fix","text":"new annotation @autohash The equality method __eq__ generated by @autodict is now correct @autodict : fixed consistency with default values of only_public_fields : it was False when using the individual decorator, but True when using @autoclass global decorator or the manual decoration method. Now it is True everywhere.","title":"1.9.2 - added autohash + fix"},{"location":"changelog/#191-a-few-fixes","text":"Now compliant with valid8 2.0.0 Fixed #13: now generated setters have default values when it was the case on the constructor.","title":"1.9.1 - a few fixes"},{"location":"changelog/#190-valid8-is-now-an-independent-project","text":"Boolean , validate , validate_decorate and all validators have been moved to an independent project, thus decoupling autoclass from the choice of validator library.","title":"1.9.0 - valid8 is now an independent project"},{"location":"changelog/#181-minor-improvements","text":"Now detecting conflicts with enforce when annotations are not in the right order (see #12 ) Added tests for on_each_ and on_all_ and fixed corresponding bugs.","title":"1.8.1 - minor improvements"},{"location":"changelog/#180-new-validators-for-collections","text":"Added on_each_ and on_all_","title":"1.8.0 - new validators for collections"},{"location":"changelog/#171-bug-fix-lts-validator","text":"lts was erroneously mappend onto gt . Fixed this.","title":"1.7.1 - bug fix: lts validator"},{"location":"changelog/#170-autoclass","text":"New decorator @autoclass to apply several features at once. @autodict now also generates a from_dict static method in the class, as well as __str__ , __repr__ and __eq__ if not present","title":"1.7.0 - @autoclass"},{"location":"changelog/#160-autodict","text":"New decorator @autodict to make a class behave like a (read-only) dict. So this is a 'dict view' on top of an object, basically the opposite of munch (that is an 'object view' on top of a dict)","title":"1.6.0 - @autodict"},{"location":"changelog/#150-robustness-and-minor-improvements","text":"better error messages for set enforcers uniform management of validators lists: now passing a list creates an 'and_' operator behind the scenes better handling of empty lists and, or, xor now automatically replace themselves with their contents when their contents is a single validator added a few tests to improve coverage (hopefully)","title":"1.5.0 - Robustness and minor improvements"},{"location":"changelog/#143-user-friendly-validators-error-messages","text":"better validation error messages for parametrized validators","title":"1.4.3 - User-friendly validators error messages"},{"location":"changelog/#142-improved-and-documented-validators","text":"improved validators list documentation added new validator: and_ fixed bugs in or_ , not_ , and xor_ : since custom validators may now throw exceptions other than ValidationError and may return None , there was a need to update them to take these cases into account not_ may now be applied to a list of validators (implicit and_ ) more unit tests for boolean validators","title":"1.4.2 - Improved and documented validators"},{"location":"changelog/#141-improved-and-documented-validation-feature","text":"A validator function may now return None improved documentation on @validate in particular for custom validators implementation","title":"1.4.1 - Improved and documented validation feature"},{"location":"changelog/#140-added-validation-feature","text":"New: @validate annotation allowing to implement input validation. Comes with a bunch of built-in validators.","title":"1.4.0 - Added validation feature"},{"location":"changelog/#131-documentation-and-travis-integration-2","text":"Improved documentation Automatic test report generation in travis Automatic PyPI deployment on tags in travis","title":"1.3.1 - Documentation and Travis integration 2"},{"location":"changelog/#130-project-renaming","text":"classtools-autocode Project was renamed autoclass for clarity Travis configuration was updated accordingly","title":"1.3.0 - Project renaming"},{"location":"changelog/#120-performance-and-documentation","text":"improved examples in the documentation improved performance of var_checker (lessons learnt from parsyfiles)","title":"1.2.0 - Performance and documentation"},{"location":"changelog/#110-mkdocs-and-enforce","text":"now using mkdocs to generate the documentation from markdown @autoprops : generated getters and setters now have correct PEP484 signature, which makes the library compliant with enforce updated documentation accordingly","title":"1.1.0 - Mkdocs and enforce"},{"location":"changelog/#100-first-public-working-version-with-pycontracts","text":"","title":"1.0.0 - First public working version with PyContracts"},{"location":"long_description/","text":"python-autoclass \u00b6 Write compact python classes Helps you to write compact python classes. The documentation for users is available here: https://smarie.github.io/python-autoclass/ A readme for developers is available here: https://github.com/smarie/python-autoclass","title":"python-autoclass"},{"location":"long_description/#python-autoclass","text":"Write compact python classes Helps you to write compact python classes. The documentation for users is available here: https://smarie.github.io/python-autoclass/ A readme for developers is available here: https://github.com/smarie/python-autoclass","title":"python-autoclass"},{"location":"usage/","text":"Usage details \u00b6 1. Fields \u00b6 If you use another library to define your class fields ( pyfields is the only one supported as of 2.1.0), you can skip this section and jump directly to section 2. . Otherwise, these two decorators can be useful to do something equivalent. @autoargs \u00b6 Automatically affects the contents of a function to self. Initial code and test examples from this answer from utnubu . A few illustrative examples can be found below. Basic functionality, no customization - all constructor arguments are auto-assigned: from autoclass import autoargs class A ( object ): @autoargs def __init__ ( self , foo , path , debug = False ): pass # Test : # -- create an instance a = A ( 'rhubarb' , 'pie' , debug = True ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' assert a . path == 'pie' assert a . debug == True Basic functionality, with special case of variable arguments *args . Note that the variable arguments are stored in a single attribute: class B ( object ): @autoargs def __init__ ( self , foo , path , debug = False , * args ): pass # Test : # -- create an instance a = B ( 'rhubarb' , 'pie' , True , 100 , 101 ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' assert a . path == 'pie' assert a . debug == True # -- *args is in a single attribute assert a . args == ( 100 , 101 ) Basic functionality, with special case of variable arguments *args and keyword arguments **kw . Note that *args are stored in a single attribute and now **kw are, too (for consistency reasons this changed in 1.10.0). class C ( object ): @autoargs def __init__ ( self , foo , path , debug = False , * args , ** kw ): pass # Test : # -- create an instance a = C ( 'rhubarb' , 'pie' , True , 100 , 101 , verbose = True , bar = 'bar' ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' assert a . path == 'pie' assert a . debug == True # -- *args is in a single attribute assert a . args == ( 100 , 101 ) # -- **kw is in a single attribute too assert a . kw == dict ( verbose = True , bar = 'bar' ) Explicit tuple or list of names to include: class C ( object ): @autoargs ( include = [ 'bar' , 'baz' , 'verbose' ]) def __init__ ( self , foo , bar , baz , verbose = False ): pass # Test : # -- create an instance a = C ( 'rhubarb' , 'pie' , 1 ) # -- check that the fields exist and have the correct value assert a . bar == 'pie' assert a . baz == 1 assert a . verbose == False # -- check that a non-included field does not exist print ( a . foo ) # raises AttributeError Explicit tuple or list of names to exclude: class C ( object ): @autoargs ( exclude = ( 'bar' , 'baz' , 'verbose' )) def __init__ ( self , foo , bar , baz , verbose = False ): pass # Test : # -- create an instance a = C ( 'rhubarb' , 'pie' , 1 ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' # -- check that the non-included fields do not exist print ( a . bar ) # raises AttributeError print ( a . baz ) # raises AttributeError print ( a . verbose ) # raises AttributeError Finally note that @autoargs is automatically applied when you decorate the whole class with @autoclass , see below. @autoprops \u00b6 Automatically generates all properties getters and setters from the class constructor. Basic functionality, no customization - all constructor arguments become properties: @autoprops class FooConfigA ( object ): @autoargs def __init__ ( self , a : str , b : List [ str ]): pass t = FooConfigA ( 'rhubarb' , [ 'pie' , 'pie2' ]) # there are no contracts on the generated setters t . a = '' t . b = [ 'r' , '' ] # check that the generated getters work assert t . a == '' assert t . b [ 0 ] == 'r' You can include or exclude some properties in the list of those generated with : @autoprops ( include = ( 'a' , 'b' )) class Foo ( object ): ... @autoprops ( exclude = ( 'b' )) class Bar ( object ): ... if a PyContracts @contract annotation exist on the __init__ method, mentioning a contract for a given parameter, the parameter contract will be added on the generated setter method: from contracts import ContractNotRespected , contract @autoprops class FooConfigB ( object ): @autoargs @contract ( a = 'str[>0]' , b = 'list[>0](str[>0])' ) def __init__ ( self , a : str , b : List [ str ]): pass t = FooConfigB ( 'rhubarb' , [ 'pie' , 'pie2' ]) # check that the generated getters work t . b = [ 'r' ] assert t . b [ 0 ] == 'r' # check that there are contracts on the generated setters t . a = '' # raises ContractNotRespected t . b = [ 'r' , '' ] # raises ContractNotRespected if a @validate annotation (from valid8 library) exist on the __init__ method, mentioning a contract for a given parameter, the parameter contract will be added on the generated setter method: # we use valid8 as the value validator from valid8 import validate @autoprops class FooConfigC ( object ): @autoargs @validate ( a = minlens ( 0 )) def __init__ ( self , a : str ): pass t = FooConfigC ( 'rhubarb' ) # check that the generated getters work t . a = 'r' assert t . a == 'r' # check that there are validators on the generated setters t . a = '' # raises ValidationError The user may override the generated getter and/or setter by creating them explicitly in the class and annotating them with @getter_override or @setter_override . Note that the contract will still be dynamically added on the setter, even if the setter already has one (in such case a UserWarning will be issued) @autoprops class FooConfigD ( object ): @autoargs @contract ( a = 'str[>0]' , b = 'list[>0](str[>0])' ) def __init__ ( self , a : str , b : List [ str ]): pass @getter_override def a ( self ): # in addition to getting the fields we'd like to print something print ( 'a is being read. Its value is \\' ' + str ( self . _a ) + ' \\' ' ) return self . _a @setter_override ( attribute = 'b' ) def another_name ( self , toto : List [ str ]): # in addition to setting the fields we'd like to print something print ( 'Property \\' b \\' was set to \\' ' + str ( toto ) + ' \\' ' ) self . _b = toto t = FooConfigD ( 'rhubarb' , [ 'pie' , 'pie2' ]) # check that we can still read a's value assert t . a == 'rhubarb' # check that 'b' still has a getter generated t . b = [ 'eh' , 'oh' ] assert t . b == [ 'eh' , 'oh' ] # check that 'a' still has a contract on its setter t . a = '' # raises ContractNotRespected # check that 'b' still has a contract on its setter t . b = [ '' ] # raises ContractNotRespected Note: you may also perform the same action without decorator, using autoprops_decorate(cls) . # we don't use @autoprops here class FooConfigD ( object ): @autoargs @contract ( a = 'str[>0]' , b = 'list[>0](str[>0])' ) def __init__ ( self , a : str , b : List [ str ]): pass # we execute it here autoprops_decorate ( FooConfigD ) t = FooConfigD ( 'rhubarb' , [ 'pie' , 'pie2' ]) # check that the generated getters work t . b = [ 'r' ] assert t . b [ 0 ] == 'r' # check that there are contracts on the generated setters t . a = '' # raises ContractNotRespected t . b = [ 'r' , '' ] # raises ContractNotRespected Finally note that @autoprops is automatically applied when you decorate the whole class with @autoclass , see below. 2. Facets \u00b6 These facets all support two ways of defining the fields: from pyfields or from the constructor signature (just like @autoprops does) @autodict \u00b6 Automatically generates a read-only dictionary view on top of the object. It does several things: it adds collections.Mapping to the list of parent classes (i.e. to the class' __bases__ ) it generates __len__ , __iter__ and __getitem__ in order for the appropriate fields to be exposed in the dict view. Parameters allow to customize the list of fields that will be visible. Note that any methods with the same name will be overridden. if only_known_fields is True (default), it generates a static from_dict method in the class corresponding to a call to the constructor with the unfolded dict. Note that this method may be overridden by the user. if __eq__ is not implemented on this class, it generates a version that handles the case self == other where other is of the same type. In that case the dictionary equality is used. Other equality tests remain unchanged. if __str__ and __repr__ are not implemented on this class, it generates them too. Examples: Basic functionality, no customization - all constructor arguments can be viewed in the dict: @autodict class A ( object ): def __init__ ( self , a : int , b : str ): self . a = a self . b = b o = A ( 1 , 'r' ) # o behaves like a read-only dict assert o == dict ( o ) assert o == { 'a' : 1 , 'b' : 'r' } # you can create an object from a dict too, thanks to the generated class function p = A . from_dict ({ 'a' : 1 , 'b' : 'r' }) assert p == o # str and repr methods show interesting stuff str ( p ) # \"A({'a': 1, 'b': 'r'})\" repr ( p ) # \"A({'a': 1, 'b': 'r'})\" You can obviously combine it with @autoargs : @autodict class B ( object ): @autoargs def __init__ ( self , a : int , b : str ): pass o = B ( 1 , 'r' ) # same results assert o == { 'a' : 1 , 'b' : 'r' } p = B . from_dict ({ 'a' : 1 , 'b' : 'r' }) assert p == o Note that by default only fields with the same name than constructor arguments are visible: @autodict class C ( object ): @autoargs def __init__ ( self , a : str , b : List [ str ]): self . non_constructor_arg = 't' self . _private = 1 self . __class_private = 't' o = C ( 1 , 'r' ) # only fields corresponding to constructor arguments are visible assert o == { 'a' : 1 , 'b' : 'r' } You can decide to open to all object fields, including or excluding (default) the fields that are not arguments of the constructor, and including or excluding (default) the class-private ones. Note that class-private attributes will be visible with their usual scrambled name: @autodict ( only_known_fields = False , only_public_fields = False ) class D ( object ): @autoargs def __init__ ( self , a : str , b : List [ str ]): self . non_constructor_arg = 'b' self . _private = 1 self . __class_private = 't' o = D ( 1 , 'r' ) # o behaves like a read-only dict, all fields are now visible assert o == dict ( o ) assert o == { 'a' : 1 , 'b' : 'r' , 'non_constructor_arg' : 'b' , '_private' : 1 , '_D__class_private' : 't' } # notice the name In addition, you can include or exclude some names in the list of visible fields with one of include or exclude : @autodict ( include = [ 'a' , 'b' ], ... ) class Foo ( object ): ... @autodict ( exclude = [ 'b' ], ... ) class Bar ( object ): ... Finally note that @autodict is automatically applied when you decorate the whole class with @autoclass , see below. @autohash \u00b6 A decorator to makes objects of the class implement hash , so that they can be used correctly for example in sets. Parameters allow to customize the list of attributes that are taken into account in the hash. Examples: Basic functionality, no customization - all object fields are used in the hash: @autohash class A ( object ): def __init__ ( self , a : int , b : str ): self . a = a self . b = b o = A ( 1 , 'r' ) o . _test = 2 # o is hashable assert hash ( o ) == hash (( 1 , 'r' , 2 )) p = A ( 1 , 'r' ) p . _test = 2 # o and p have identical hash assert hash ( o ) == hash ( p ) # dynamic and private fields are taken into account by default p . _test = 3 assert hash ( o ) != hash ( p ) You can decide to restrict the hash to only the fields that are constructor arguments, or to only the fields that are public: from random import random @autohash ( only_known_fields = True , only_public_fields = True ) class D ( object ): @autoargs def __init__ ( self , a : str , _b : str ): self . non_constructor_arg = random () self . _private = random () self . __class_private = random () o = D ( 1 , 'r' ) p = D ( 1 , 'r' ) # o and p have the same hash because only the constructor arguments are taken into account assert hash ( o ) == hash ( p ) assert hash ( o ) == hash (( 1 , 'r' )) In addition, you can include or exclude some names in the list of visible fields with one of include or exclude : @autohash ( include = [ 'a' , 'b' ], ... ) class Foo ( object ): ... @autohash ( exclude = [ 'b' ], ... ) class Bar ( object ): ... Finally note that @autohash is automatically applied when you decorate the whole class with @autoclass , see below. @autorepr \u00b6 This decorator is useful if you wish to add a string representation to your class but you do not wish to use the entire @autodict . It just creates the __str__ and __repr__ methods. @autoeq \u00b6 This decorator is useful if you wish to add an equality method to your class but you do not wish to use the entire @autodict . It just creates the __eq__ method. @autoslots \u00b6 Automatically create slots for each attribute. Parameters allow to customize the list of attributes that are taken into account. Examples: Basic functionality, no customization - all object fields are used in the slots, and a __weakref__ is automatically added: from autoclass import autoslots @autoslots class Foo ( object ): def __init__ ( self , foo1 , foo2 = 0 ): self . foo1 = foo1 self . foo2 = foo2 f = Foo ( 1 ) assert not hasattr ( f , '__dict__' ) assert f . foo1 == 1 assert f . foo2 == 0 private slot names can be created instead of public ones: from autoclass import autoslots , autoargs , autoprops @autoprops @autoslots ( use_public_names = False ) class Foo ( object ): @autoargs def __init__ ( self , foo1 , foo2 = 0 ): pass f = Foo ( 1 ) assert not hasattr ( f , '__dict__' ) assert f . foo1 == 1 assert f . foo2 == 0 In addition, you can include or exclude some names in the list of fields with one of include or exclude : @autoslots ( include = [ 'a' , 'b' ], ... ) class Foo ( object ): ... @autoslots ( exclude = [ 'b' ], ... ) class Bar ( object ): ... Finally note that @autoslots is not automatically applied when you decorate the whole class with @autoclass , you have to use @autoclass(autoslots=True) see below. @autoclass \u00b6 Applies all or part of the above decorators at once. Useful if you want to make the most from this library. Basic functionality, no customization - all constructor arguments become properties that are auto-assigned in constructor, and the object behaves like a dict and can be created from a dict: from numbers import Integral from typing import Optional # we will use enforce as the runtime checker import enforce as en from enforce import runtime_validation en . config ( dict ( mode = 'covariant' )) # allow subclasses when validating types # we use valid8 as the value validator from valid8 import validate # class definition @runtime_validation @autoclass class AllOfTheAbove : @validate ( a = gt ( 1 ), c = minlen ( 1 )) def __init__ ( self , a : Integral , b : Boolean , c : Optional [ List [ str ]] = None ): pass # instance creation o = AllOfTheAbove ( a = 2 , b = True ) # @autoargs works assert o . a == 2 # @autoprops works, in combination with any runtime checker (here demonstrated with enforce) o . b = 1 # !RuntimeTypeError Argument 'b' was not of type Boolean. Actual type was int. # @autodict works assert o == { 'a' : 2 , 'b' : True , 'c' : None } assert AllOfTheAbove . from_dict ( o ) == o assert dict ( ** o ) == o you can also disable part of the features : @autoclass ( autodict = False ) class PartsOfTheAbove : @validate ( a = gt ( 1 ), c = minlen ( 1 )) def __init__ ( self , a : Integral , b : Boolean , c : Optional [ List [ str ]] = None ): pass # instance creation o = PartsOfTheAbove ( a = 2 , b = True ) print ( o ) # works: autorepr is automatically enabled when autodict=False assert o == { 'a' : 2 , 'b' : True , 'c' : None } # AssertionError assert o == PartsOfTheAbove ( a = 2 , b = True ) # works: autoeq is automatically enabled assert PartsOfTheAbove . from_dict ( o ) == o # AttributeError: 'PartsOfTheAbove' has no attribute 'from_dict' assert dict ( ** o ) == o # TypeError: argument after ** must be a mapping Alternative to decorators: manual function wrappers \u00b6 Equivalent manual wrapper methods are provided for all decorators in this library: autoargs_decorate(init_func, include, exclude) , autoprops_decorate(cls, include, exclude) , autoprops_override_decorate(func, attribute, is_getter) , autodict_decorate(cls, include, exclude, only_known_fields, only_public_fields) , autoclass_decorate(cls, include, exclude, autoargs, autoprops, autodict) , autoslots_decorate(cls, include, exclude, use_public_names, add_weakref_slot) Therefore you can do: from autoclass import autoclass_decorate class A : ... A = autoclass_decorate ( A )","title":"Usage details"},{"location":"usage/#usage-details","text":"","title":"Usage details"},{"location":"usage/#1-fields","text":"If you use another library to define your class fields ( pyfields is the only one supported as of 2.1.0), you can skip this section and jump directly to section 2. . Otherwise, these two decorators can be useful to do something equivalent.","title":"1. Fields"},{"location":"usage/#autoargs","text":"Automatically affects the contents of a function to self. Initial code and test examples from this answer from utnubu . A few illustrative examples can be found below. Basic functionality, no customization - all constructor arguments are auto-assigned: from autoclass import autoargs class A ( object ): @autoargs def __init__ ( self , foo , path , debug = False ): pass # Test : # -- create an instance a = A ( 'rhubarb' , 'pie' , debug = True ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' assert a . path == 'pie' assert a . debug == True Basic functionality, with special case of variable arguments *args . Note that the variable arguments are stored in a single attribute: class B ( object ): @autoargs def __init__ ( self , foo , path , debug = False , * args ): pass # Test : # -- create an instance a = B ( 'rhubarb' , 'pie' , True , 100 , 101 ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' assert a . path == 'pie' assert a . debug == True # -- *args is in a single attribute assert a . args == ( 100 , 101 ) Basic functionality, with special case of variable arguments *args and keyword arguments **kw . Note that *args are stored in a single attribute and now **kw are, too (for consistency reasons this changed in 1.10.0). class C ( object ): @autoargs def __init__ ( self , foo , path , debug = False , * args , ** kw ): pass # Test : # -- create an instance a = C ( 'rhubarb' , 'pie' , True , 100 , 101 , verbose = True , bar = 'bar' ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' assert a . path == 'pie' assert a . debug == True # -- *args is in a single attribute assert a . args == ( 100 , 101 ) # -- **kw is in a single attribute too assert a . kw == dict ( verbose = True , bar = 'bar' ) Explicit tuple or list of names to include: class C ( object ): @autoargs ( include = [ 'bar' , 'baz' , 'verbose' ]) def __init__ ( self , foo , bar , baz , verbose = False ): pass # Test : # -- create an instance a = C ( 'rhubarb' , 'pie' , 1 ) # -- check that the fields exist and have the correct value assert a . bar == 'pie' assert a . baz == 1 assert a . verbose == False # -- check that a non-included field does not exist print ( a . foo ) # raises AttributeError Explicit tuple or list of names to exclude: class C ( object ): @autoargs ( exclude = ( 'bar' , 'baz' , 'verbose' )) def __init__ ( self , foo , bar , baz , verbose = False ): pass # Test : # -- create an instance a = C ( 'rhubarb' , 'pie' , 1 ) # -- check that the fields exist and have the correct value assert a . foo == 'rhubarb' # -- check that the non-included fields do not exist print ( a . bar ) # raises AttributeError print ( a . baz ) # raises AttributeError print ( a . verbose ) # raises AttributeError Finally note that @autoargs is automatically applied when you decorate the whole class with @autoclass , see below.","title":"@autoargs"},{"location":"usage/#autoprops","text":"Automatically generates all properties getters and setters from the class constructor. Basic functionality, no customization - all constructor arguments become properties: @autoprops class FooConfigA ( object ): @autoargs def __init__ ( self , a : str , b : List [ str ]): pass t = FooConfigA ( 'rhubarb' , [ 'pie' , 'pie2' ]) # there are no contracts on the generated setters t . a = '' t . b = [ 'r' , '' ] # check that the generated getters work assert t . a == '' assert t . b [ 0 ] == 'r' You can include or exclude some properties in the list of those generated with : @autoprops ( include = ( 'a' , 'b' )) class Foo ( object ): ... @autoprops ( exclude = ( 'b' )) class Bar ( object ): ... if a PyContracts @contract annotation exist on the __init__ method, mentioning a contract for a given parameter, the parameter contract will be added on the generated setter method: from contracts import ContractNotRespected , contract @autoprops class FooConfigB ( object ): @autoargs @contract ( a = 'str[>0]' , b = 'list[>0](str[>0])' ) def __init__ ( self , a : str , b : List [ str ]): pass t = FooConfigB ( 'rhubarb' , [ 'pie' , 'pie2' ]) # check that the generated getters work t . b = [ 'r' ] assert t . b [ 0 ] == 'r' # check that there are contracts on the generated setters t . a = '' # raises ContractNotRespected t . b = [ 'r' , '' ] # raises ContractNotRespected if a @validate annotation (from valid8 library) exist on the __init__ method, mentioning a contract for a given parameter, the parameter contract will be added on the generated setter method: # we use valid8 as the value validator from valid8 import validate @autoprops class FooConfigC ( object ): @autoargs @validate ( a = minlens ( 0 )) def __init__ ( self , a : str ): pass t = FooConfigC ( 'rhubarb' ) # check that the generated getters work t . a = 'r' assert t . a == 'r' # check that there are validators on the generated setters t . a = '' # raises ValidationError The user may override the generated getter and/or setter by creating them explicitly in the class and annotating them with @getter_override or @setter_override . Note that the contract will still be dynamically added on the setter, even if the setter already has one (in such case a UserWarning will be issued) @autoprops class FooConfigD ( object ): @autoargs @contract ( a = 'str[>0]' , b = 'list[>0](str[>0])' ) def __init__ ( self , a : str , b : List [ str ]): pass @getter_override def a ( self ): # in addition to getting the fields we'd like to print something print ( 'a is being read. Its value is \\' ' + str ( self . _a ) + ' \\' ' ) return self . _a @setter_override ( attribute = 'b' ) def another_name ( self , toto : List [ str ]): # in addition to setting the fields we'd like to print something print ( 'Property \\' b \\' was set to \\' ' + str ( toto ) + ' \\' ' ) self . _b = toto t = FooConfigD ( 'rhubarb' , [ 'pie' , 'pie2' ]) # check that we can still read a's value assert t . a == 'rhubarb' # check that 'b' still has a getter generated t . b = [ 'eh' , 'oh' ] assert t . b == [ 'eh' , 'oh' ] # check that 'a' still has a contract on its setter t . a = '' # raises ContractNotRespected # check that 'b' still has a contract on its setter t . b = [ '' ] # raises ContractNotRespected Note: you may also perform the same action without decorator, using autoprops_decorate(cls) . # we don't use @autoprops here class FooConfigD ( object ): @autoargs @contract ( a = 'str[>0]' , b = 'list[>0](str[>0])' ) def __init__ ( self , a : str , b : List [ str ]): pass # we execute it here autoprops_decorate ( FooConfigD ) t = FooConfigD ( 'rhubarb' , [ 'pie' , 'pie2' ]) # check that the generated getters work t . b = [ 'r' ] assert t . b [ 0 ] == 'r' # check that there are contracts on the generated setters t . a = '' # raises ContractNotRespected t . b = [ 'r' , '' ] # raises ContractNotRespected Finally note that @autoprops is automatically applied when you decorate the whole class with @autoclass , see below.","title":"@autoprops"},{"location":"usage/#2-facets","text":"These facets all support two ways of defining the fields: from pyfields or from the constructor signature (just like @autoprops does)","title":"2. Facets"},{"location":"usage/#autodict","text":"Automatically generates a read-only dictionary view on top of the object. It does several things: it adds collections.Mapping to the list of parent classes (i.e. to the class' __bases__ ) it generates __len__ , __iter__ and __getitem__ in order for the appropriate fields to be exposed in the dict view. Parameters allow to customize the list of fields that will be visible. Note that any methods with the same name will be overridden. if only_known_fields is True (default), it generates a static from_dict method in the class corresponding to a call to the constructor with the unfolded dict. Note that this method may be overridden by the user. if __eq__ is not implemented on this class, it generates a version that handles the case self == other where other is of the same type. In that case the dictionary equality is used. Other equality tests remain unchanged. if __str__ and __repr__ are not implemented on this class, it generates them too. Examples: Basic functionality, no customization - all constructor arguments can be viewed in the dict: @autodict class A ( object ): def __init__ ( self , a : int , b : str ): self . a = a self . b = b o = A ( 1 , 'r' ) # o behaves like a read-only dict assert o == dict ( o ) assert o == { 'a' : 1 , 'b' : 'r' } # you can create an object from a dict too, thanks to the generated class function p = A . from_dict ({ 'a' : 1 , 'b' : 'r' }) assert p == o # str and repr methods show interesting stuff str ( p ) # \"A({'a': 1, 'b': 'r'})\" repr ( p ) # \"A({'a': 1, 'b': 'r'})\" You can obviously combine it with @autoargs : @autodict class B ( object ): @autoargs def __init__ ( self , a : int , b : str ): pass o = B ( 1 , 'r' ) # same results assert o == { 'a' : 1 , 'b' : 'r' } p = B . from_dict ({ 'a' : 1 , 'b' : 'r' }) assert p == o Note that by default only fields with the same name than constructor arguments are visible: @autodict class C ( object ): @autoargs def __init__ ( self , a : str , b : List [ str ]): self . non_constructor_arg = 't' self . _private = 1 self . __class_private = 't' o = C ( 1 , 'r' ) # only fields corresponding to constructor arguments are visible assert o == { 'a' : 1 , 'b' : 'r' } You can decide to open to all object fields, including or excluding (default) the fields that are not arguments of the constructor, and including or excluding (default) the class-private ones. Note that class-private attributes will be visible with their usual scrambled name: @autodict ( only_known_fields = False , only_public_fields = False ) class D ( object ): @autoargs def __init__ ( self , a : str , b : List [ str ]): self . non_constructor_arg = 'b' self . _private = 1 self . __class_private = 't' o = D ( 1 , 'r' ) # o behaves like a read-only dict, all fields are now visible assert o == dict ( o ) assert o == { 'a' : 1 , 'b' : 'r' , 'non_constructor_arg' : 'b' , '_private' : 1 , '_D__class_private' : 't' } # notice the name In addition, you can include or exclude some names in the list of visible fields with one of include or exclude : @autodict ( include = [ 'a' , 'b' ], ... ) class Foo ( object ): ... @autodict ( exclude = [ 'b' ], ... ) class Bar ( object ): ... Finally note that @autodict is automatically applied when you decorate the whole class with @autoclass , see below.","title":"@autodict"},{"location":"usage/#autohash","text":"A decorator to makes objects of the class implement hash , so that they can be used correctly for example in sets. Parameters allow to customize the list of attributes that are taken into account in the hash. Examples: Basic functionality, no customization - all object fields are used in the hash: @autohash class A ( object ): def __init__ ( self , a : int , b : str ): self . a = a self . b = b o = A ( 1 , 'r' ) o . _test = 2 # o is hashable assert hash ( o ) == hash (( 1 , 'r' , 2 )) p = A ( 1 , 'r' ) p . _test = 2 # o and p have identical hash assert hash ( o ) == hash ( p ) # dynamic and private fields are taken into account by default p . _test = 3 assert hash ( o ) != hash ( p ) You can decide to restrict the hash to only the fields that are constructor arguments, or to only the fields that are public: from random import random @autohash ( only_known_fields = True , only_public_fields = True ) class D ( object ): @autoargs def __init__ ( self , a : str , _b : str ): self . non_constructor_arg = random () self . _private = random () self . __class_private = random () o = D ( 1 , 'r' ) p = D ( 1 , 'r' ) # o and p have the same hash because only the constructor arguments are taken into account assert hash ( o ) == hash ( p ) assert hash ( o ) == hash (( 1 , 'r' )) In addition, you can include or exclude some names in the list of visible fields with one of include or exclude : @autohash ( include = [ 'a' , 'b' ], ... ) class Foo ( object ): ... @autohash ( exclude = [ 'b' ], ... ) class Bar ( object ): ... Finally note that @autohash is automatically applied when you decorate the whole class with @autoclass , see below.","title":"@autohash"},{"location":"usage/#autorepr","text":"This decorator is useful if you wish to add a string representation to your class but you do not wish to use the entire @autodict . It just creates the __str__ and __repr__ methods.","title":"@autorepr"},{"location":"usage/#autoeq","text":"This decorator is useful if you wish to add an equality method to your class but you do not wish to use the entire @autodict . It just creates the __eq__ method.","title":"@autoeq"},{"location":"usage/#autoslots","text":"Automatically create slots for each attribute. Parameters allow to customize the list of attributes that are taken into account. Examples: Basic functionality, no customization - all object fields are used in the slots, and a __weakref__ is automatically added: from autoclass import autoslots @autoslots class Foo ( object ): def __init__ ( self , foo1 , foo2 = 0 ): self . foo1 = foo1 self . foo2 = foo2 f = Foo ( 1 ) assert not hasattr ( f , '__dict__' ) assert f . foo1 == 1 assert f . foo2 == 0 private slot names can be created instead of public ones: from autoclass import autoslots , autoargs , autoprops @autoprops @autoslots ( use_public_names = False ) class Foo ( object ): @autoargs def __init__ ( self , foo1 , foo2 = 0 ): pass f = Foo ( 1 ) assert not hasattr ( f , '__dict__' ) assert f . foo1 == 1 assert f . foo2 == 0 In addition, you can include or exclude some names in the list of fields with one of include or exclude : @autoslots ( include = [ 'a' , 'b' ], ... ) class Foo ( object ): ... @autoslots ( exclude = [ 'b' ], ... ) class Bar ( object ): ... Finally note that @autoslots is not automatically applied when you decorate the whole class with @autoclass , you have to use @autoclass(autoslots=True) see below.","title":"@autoslots"},{"location":"usage/#autoclass","text":"Applies all or part of the above decorators at once. Useful if you want to make the most from this library. Basic functionality, no customization - all constructor arguments become properties that are auto-assigned in constructor, and the object behaves like a dict and can be created from a dict: from numbers import Integral from typing import Optional # we will use enforce as the runtime checker import enforce as en from enforce import runtime_validation en . config ( dict ( mode = 'covariant' )) # allow subclasses when validating types # we use valid8 as the value validator from valid8 import validate # class definition @runtime_validation @autoclass class AllOfTheAbove : @validate ( a = gt ( 1 ), c = minlen ( 1 )) def __init__ ( self , a : Integral , b : Boolean , c : Optional [ List [ str ]] = None ): pass # instance creation o = AllOfTheAbove ( a = 2 , b = True ) # @autoargs works assert o . a == 2 # @autoprops works, in combination with any runtime checker (here demonstrated with enforce) o . b = 1 # !RuntimeTypeError Argument 'b' was not of type Boolean. Actual type was int. # @autodict works assert o == { 'a' : 2 , 'b' : True , 'c' : None } assert AllOfTheAbove . from_dict ( o ) == o assert dict ( ** o ) == o you can also disable part of the features : @autoclass ( autodict = False ) class PartsOfTheAbove : @validate ( a = gt ( 1 ), c = minlen ( 1 )) def __init__ ( self , a : Integral , b : Boolean , c : Optional [ List [ str ]] = None ): pass # instance creation o = PartsOfTheAbove ( a = 2 , b = True ) print ( o ) # works: autorepr is automatically enabled when autodict=False assert o == { 'a' : 2 , 'b' : True , 'c' : None } # AssertionError assert o == PartsOfTheAbove ( a = 2 , b = True ) # works: autoeq is automatically enabled assert PartsOfTheAbove . from_dict ( o ) == o # AttributeError: 'PartsOfTheAbove' has no attribute 'from_dict' assert dict ( ** o ) == o # TypeError: argument after ** must be a mapping","title":"@autoclass"},{"location":"usage/#alternative-to-decorators-manual-function-wrappers","text":"Equivalent manual wrapper methods are provided for all decorators in this library: autoargs_decorate(init_func, include, exclude) , autoprops_decorate(cls, include, exclude) , autoprops_override_decorate(func, attribute, is_getter) , autodict_decorate(cls, include, exclude, only_known_fields, only_public_fields) , autoclass_decorate(cls, include, exclude, autoargs, autoprops, autodict) , autoslots_decorate(cls, include, exclude, use_public_names, add_weakref_slot) Therefore you can do: from autoclass import autoclass_decorate class A : ... A = autoclass_decorate ( A )","title":"Alternative to decorators: manual function wrappers"}]}